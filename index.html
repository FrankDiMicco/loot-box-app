<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loot Box Creator</title>
  
  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  
  <style>
    /* Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --color-bg-primary: #0a0e1a;
      --color-bg-secondary: #0f1624;
      --color-bg-tertiary: #1a1f35;
      --color-bg-card: rgba(26, 31, 53, 0.6);
      
      --color-brand-primary: #1e40af;
      --color-brand-secondary: #2563eb;
      --color-brand-accent: #3b82f6;
      
      --color-text-primary: #e2e8f0;
      --color-text-secondary: #cbd5e1;
      --color-text-tertiary: #94a3b8;
      
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      
      --radius-md: 12px;
      --radius-lg: 16px;
      
      --transition-normal: 0.25s ease;
    }

    body {
      font-family: var(--font-sans);
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 100%);
      color: var(--color-text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(15, 22, 36, 0.5);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(59, 130, 246, 0.3);
      border-radius: 10px;
      transition: background 0.3s ease;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(59, 130, 246, 0.6);
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.4);
    }

    /* Firefox scrollbar */
    * {
      scrollbar-width: thin;
      scrollbar-color: rgba(59, 130, 246, 0.3) rgba(15, 22, 36, 0.5);
    }

    /* Selection */
    ::selection {
      background: rgba(59, 130, 246, 0.3);
      color: var(--color-text-primary);
    }

    *:focus {
      outline: none;
    }

    *:focus-visible {
      outline: 2px solid var(--color-brand-primary);
      outline-offset: 2px;
    }

    html {
      scroll-behavior: smooth;
    }

    button {
      user-select: none;
      -webkit-user-select: none;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(4px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes toastSlideUp {
      from {
        opacity: 0;
        transform: translate(-50%, 20px);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }

    /* Enhanced box wiggle - initial tap feedback */
    @keyframes boxWiggle {
      0% { transform: rotate(0); }
      20% { transform: rotate(-8deg); }
      40% { transform: rotate(8deg); }
      60% { transform: rotate(-5deg); }
      80% { transform: rotate(5deg); }
      100% { transform: rotate(0); }
    }

    /* Intense shake with escalating glow - replaces spin */
    @keyframes intenseShake {
      0% { transform: translate(0, 0) rotate(0deg); filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.3)); }
      10% { transform: translate(-3px, 0) rotate(-2deg); }
      20% { transform: translate(3px, -2px) rotate(2deg); filter: drop-shadow(0 0 12px rgba(59, 130, 246, 0.5)); }
      30% { transform: translate(-4px, 1px) rotate(-3deg); }
      40% { transform: translate(4px, -1px) rotate(3deg); filter: drop-shadow(0 0 20px rgba(245, 158, 11, 0.6)); }
      50% { transform: translate(-5px, 2px) rotate(-4deg); }
      60% { transform: translate(5px, -2px) rotate(4deg); filter: drop-shadow(0 0 30px rgba(245, 158, 11, 0.8)); }
      70% { transform: translate(-6px, 1px) rotate(-5deg); }
      80% { transform: translate(6px, -1px) rotate(5deg); filter: drop-shadow(0 0 40px rgba(245, 158, 11, 1)); }
      90% { transform: translate(-3px, 0) rotate(-2deg); filter: drop-shadow(0 0 50px rgba(255, 255, 255, 0.8)); }
      100% { transform: translate(0, 0) rotate(0deg) scale(1.1); filter: drop-shadow(0 0 60px rgba(255, 255, 255, 1)); }
    }

    /* Glow ring pulse behind chest */
    @keyframes glowPulse {
      0% { opacity: 0; transform: scale(0.5); box-shadow: 0 0 20px rgba(59, 130, 246, 0.3); }
      30% { opacity: 0.6; transform: scale(0.8); box-shadow: 0 0 40px rgba(59, 130, 246, 0.5), 0 0 80px rgba(245, 158, 11, 0.3); }
      60% { opacity: 0.9; transform: scale(1); box-shadow: 0 0 60px rgba(245, 158, 11, 0.8), 0 0 120px rgba(245, 158, 11, 0.4); }
      100% { opacity: 0; transform: scale(1.5); box-shadow: 0 0 80px rgba(255, 255, 255, 0.6), 0 0 160px rgba(245, 158, 11, 0.2); }
    }

    /* White flash burst */
    @keyframes flashBurst {
      0% { opacity: 1; transform: scale(0.5); }
      50% { opacity: 0.8; transform: scale(1.2); }
      100% { opacity: 0; transform: scale(2); }
    }

    /* Particle burst outward */
    @keyframes particleBurst {
      0% { opacity: 1; transform: translate(0, 0) scale(1); }
      60% { opacity: 0.8; }
      100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0); }
    }

    /* Result card bouncy reveal */
    @keyframes resultReveal {
      0% { opacity: 0; transform: scale(0.3) translateY(20px); }
      50% { opacity: 1; transform: scale(1.08) translateY(-5px); }
      70% { transform: scale(0.96) translateY(0); }
      100% { opacity: 1; transform: scale(1) translateY(0); }
    }

    /* Shimmer on result item name */
    @keyframes shimmerText {
      0% { filter: brightness(1); }
      50% { filter: brightness(1.5); }
      100% { filter: brightness(1); }
    }

    @keyframes boxIdle {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-6px); }
    }

    @keyframes tapHint {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }

    @keyframes glow {
      0%, 100% {
        box-shadow: 0 0 25px rgba(59, 130, 246, 0.5);
      }
      50% {
        box-shadow: 0 0 40px rgba(59, 130, 246, 0.8);
      }
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      body {
        font-size: 14px;
      }
      
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
    }

    /* Remove number input spinners */
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    .mobile-image-scroll::-webkit-scrollbar {
      display: none;
    }
    .mobile-image-scroll {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    input::placeholder, textarea::placeholder {
      color: rgba(148, 163, 184, 0.4) !important;
      font-family: inherit !important;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    const { useState, useEffect, useRef } = React;

    // ========== FIREBASE CONFIGURATION ==========

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyCo5QnH9iEZL7fprJxs96y9WMq5dk1uxd8",
      authDomain: "lootbox-app-dd5fa.firebaseapp.com",
      projectId: "lootbox-app-dd5fa",
      storageBucket: "lootbox-app-dd5fa.firebasestorage.app",
      messagingSenderId: "16386037455",
      appId: "1:16386037455:web:df2ef3eb25929357dfc9ba",
      measurementId: "G-3KSR19L05G"
    };

    // Initialize Firebase (only if config is valid)
    let db = null;
    let storage = null;
    let auth = null;
    let firebaseEnabled = false;

    try {
      if (firebaseConfig.apiKey !== "YOUR_API_KEY") {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        storage = firebase.storage();
        auth = firebase.auth();
        firebaseEnabled = true;
        console.log('Firebase initialized successfully');
      } else {
        console.warn('Firebase not configured - using local-only mode');
      }
    } catch (error) {
      console.error('Firebase initialization failed:', error);
    }

    // ========== BOX SOURCE TYPES ==========

    const BOX_SOURCES = {
      DEFAULT: 'default',      // Hardcoded, always available
      SEASONAL: 'seasonal',    // Time-limited from Firebase
      STORE: 'store',         // Purchasable from Firebase
      PREMIUM: 'premium',     // Premium-only boxes from Firebase
      USER_UPLOADED: 'user',  // User-created, uploaded to Firebase (premium)
      LOCAL: 'local',         // User-created locally (current system)
    };

    // ========== BOX IMAGE CATALOG ==========

    // MONETIZATION MODEL:
    // - Free Users: Get 3 default box skins for free, can purchase additional skins individually
    // - Premium Users: Unlimited local boxes, can upload custom boxes, still purchase skins individually
    // - All Users: Can purchase seasonal/store box skins at set prices (e.g., $0.99, $1.99, $2.99)

    // Default boxes - always available and free for all users
    const DEFAULT_BOX_IMAGES = [
      {
        id: 'chest',
        name: 'Classic Chest',
        file: 'chest.png',
        source: BOX_SOURCES.DEFAULT,
        price: null,
        seasonalInfo: null,
        imageUrl: './assets/images/boxes/free/chest.png'
      },
      {
        id: 'skull_bone',
        name: 'Skull Chest',
        file: 'skull_bone.png',
        source: BOX_SOURCES.DEFAULT,
        price: null,
        seasonalInfo: null,
        imageUrl: './assets/images/boxes/free/skull_bone.png'
      },
      {
        id: 'metal',
        name: 'Metal Chest',
        file: 'metal.png',
        source: BOX_SOURCES.DEFAULT,
        price: null,
        seasonalInfo: null,
        imageUrl: './assets/images/boxes/free/metal.png'
      },
    ];

    // Get default images
    const getDefaultBoxImages = () => {
      return DEFAULT_BOX_IMAGES;
    };

    // Get all images as flat array (legacy compatibility)
    const getAllBoxImages = () => {
      return DEFAULT_BOX_IMAGES;
    };

    // Check if user can use an image (alias for userOwnsBox)
    const canUseBoxImage = (imageId, userSettings) => {
      return userOwnsBox(imageId, userSettings);
    };

    // Get image URL (supports both local and Firebase URLs)
    const getBoxImageUrl = (imageId, boxCatalog = null) => {
      // If imageId is already a full URL, return it directly
      if (imageId && imageId.startsWith('http')) return imageId;

      // Try to find in provided catalog first (includes Firebase boxes)
      if (boxCatalog) {
        const box = boxCatalog.all?.find(img => img.id === imageId);
        if (box) return box.imageUrl;
      }

      // Fallback to hardcoded default images
      const image = DEFAULT_BOX_IMAGES.find(img => img.id === imageId);
      if (image) return image.imageUrl;

      return null;
    };

    // ========== UTILITIES ==========
    
    // Calculate dynamic odds
    const calculateDynamicOdds = (items, pullHistory) => {
      const remainingItems = items.map(item => {
        const pulledCount = pullHistory.filter(p => p.itemId === item.id).length;
        const remaining = item.maxQuantity 
          ? Math.max(0, item.maxQuantity - pulledCount) 
          : Infinity;
        return { ...item, remaining };
      }).filter(item => item.remaining > 0);

      if (remainingItems.length === 0) return [];

      const totalPercentage = remainingItems.reduce((sum, item) => sum + item.percentage, 0);
      
      return remainingItems.map(item => ({
        ...item,
        adjustedPercentage: (item.percentage / totalPercentage) * 100
      }));
    };

    // Validate percentages
    const validatePercentages = (items) => {
      if (items.length === 0) {
        return { valid: false, total: 0, message: 'Add at least one item' };
      }

      const total = items.reduce((sum, item) => sum + parseFloat(item.percentage || 0), 0);
      const rounded = Math.round(total * 100) / 100;
      
      if (rounded === 100) {
        return { valid: true, total: rounded, message: 'Perfect!' };
      } else if (rounded < 100) {
        return { 
          valid: false, 
          total: rounded, 
          message: `Missing ${(100 - rounded).toFixed(2)}%` 
        };
      } else {
        return { 
          valid: false, 
          total: rounded, 
          message: `Over by ${(rounded - 100).toFixed(2)}%` 
        };
      }
    };

    // Get remaining percentage
    const getRemainingPercentage = (items) => {
      const total = items.reduce((sum, item) => sum + parseFloat(item.percentage || 0), 0);
      return Math.max(0, 100 - total);
    };

    // Generate share code
    const generateShareCode = () => {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let code = '';
      for (let i = 0; i < 6; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    };

    const getDeviceId = () => {
      const STORAGE_KEY = 'lootBoxDeviceId';
      try {
        let deviceId = localStorage.getItem(STORAGE_KEY);
        if (!deviceId) {
          deviceId = 'device_' + Date.now().toString(36) + '_' +
            Math.random().toString(36).substring(2, 10);
          localStorage.setItem(STORAGE_KEY, deviceId);
        }
        return deviceId;
      } catch {
        // Fallback for private browsing -- generate per-session ID
        return 'session_' + Date.now().toString(36) + '_' +
          Math.random().toString(36).substring(2, 10);
      }
    };

    // Format expiration countdown
    const formatExpirationCountdown = (expiresAt) => {
      const now = Date.now();
      const diff = expiresAt - now;
      
      if (diff <= 0) return 'Expired';
      
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const days = Math.floor(hours / 24);
      const remainingHours = hours % 24;
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      
      if (days > 0) return `${days}d ${remainingHours}h`;
      if (hours > 0) return `${hours}h ${minutes}m`;
      if (minutes > 0) return `${minutes}m`;
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);
      return `${seconds}s`;
    };

    // Check if expiring soon
    const isExpiringSoon = (expiresAt) => {
      const now = Date.now();
      const diff = expiresAt - now;
      const hoursRemaining = diff / (1000 * 60 * 60);
      return hoursRemaining > 0 && hoursRemaining <= 24;
    };

    // ========== STORAGE ==========
    
    const STORAGE_KEYS = {
      BOXES: 'lootBoxes',
      USER_SETTINGS: 'userSettings',
      FAVORITES: 'lootBoxFavorites',
    };

    const getFavorites = () => {
      try {
        const data = localStorage.getItem(STORAGE_KEYS.FAVORITES);
        return data ? JSON.parse(data) : [];
      } catch (e) {
        return [];
      }
    };

    const toggleFavorite = (boxId) => {
      const favs = getFavorites();
      const index = favs.indexOf(boxId);
      if (index > -1) {
        favs.splice(index, 1);
      } else {
        favs.push(boxId);
      }
      localStorage.setItem(STORAGE_KEYS.FAVORITES, JSON.stringify(favs));
      return favs;
    };

    const isFavorite = (boxId) => {
      return getFavorites().includes(boxId);
    };

    const getAllBoxes = () => {
      try {
        const data = localStorage.getItem(STORAGE_KEYS.BOXES);
        return data ? JSON.parse(data) : [];
      } catch (error) {
        console.error('Error reading boxes:', error);
        return [];
      }
    };

    const saveBox = (box) => {
      try {
        const boxes = getAllBoxes();
        const existingIndex = boxes.findIndex(b => b.id === box.id);
        
        if (existingIndex >= 0) {
          boxes[existingIndex] = box;
        } else {
          boxes.push(box);
        }
        
        localStorage.setItem(STORAGE_KEYS.BOXES, JSON.stringify(boxes));
        return true;
      } catch (error) {
        console.error('Error saving box:', error);
        return false;
      }
    };

    const getSeenBoxes = () => {
      try { return JSON.parse(localStorage.getItem('lootBoxSeenBoxes')) || []; }
      catch { return []; }
    };

    const markBoxAsSeen = (boxId) => {
      const seen = getSeenBoxes();
      if (!seen.includes(boxId)) {
        seen.push(boxId);
        localStorage.setItem('lootBoxSeenBoxes', JSON.stringify(seen));
      }
    };

    const deleteBox = (boxId) => {
      try {
        const boxes = getAllBoxes();
        const filtered = boxes.filter(box => box.id !== boxId);
        localStorage.setItem(STORAGE_KEYS.BOXES, JSON.stringify(filtered));
        return true;
      } catch (error) {
        console.error('Error deleting box:', error);
        return false;
      }
    };

    const getBoxById = (boxId) => {
      const boxes = getAllBoxes();
      return boxes.find(box => box.id === boxId) || null;
    };

    const getUserSettings = () => {
      try {
        const data = localStorage.getItem(STORAGE_KEYS.USER_SETTINGS);
        return data ? JSON.parse(data) : {
          tier: 'free',
          localBoxCount: 0,
          displayName: '',
          soundEnabled: true,
          theme: 'dark',
          uid: null,  // Firebase user ID
          ownedBoxes: [],  // Store and seasonal purchases
          uploadedBoxes: [],  // User's uploaded boxes
          purchasedBoxImages: [], // Legacy - kept for compatibility
        };
      } catch (error) {
        return {
          tier: 'free',
          localBoxCount: 0,
          displayName: '',
          soundEnabled: true,
          theme: 'dark',
          uid: null,
          ownedBoxes: [],
          uploadedBoxes: [],
          purchasedBoxImages: [],
        };
      }
    };

    const saveUserSettings = (settings) => {
      try {
        localStorage.setItem(STORAGE_KEYS.USER_SETTINGS, JSON.stringify(settings));
        return true;
      } catch (error) {
        console.error('Error saving user settings:', error);
        return false;
      }
    };

    // Get display name for a specific box
    const getBoxUserName = (shareCode) => {
      try {
        const names = JSON.parse(localStorage.getItem('lootBoxUserNames') || '{}');
        return names[shareCode] || '';
      } catch { return ''; }
    };

    // Save display name for a specific box
    const setBoxUserName = (shareCode, name) => {
      try {
        const names = JSON.parse(localStorage.getItem('lootBoxUserNames') || '{}');
        names[shareCode] = name;
        localStorage.setItem('lootBoxUserNames', JSON.stringify(names));
      } catch {}
    };

    // Get the most recently used name (for pre-filling)
    const getLastUsedName = () => {
      try {
        return localStorage.getItem('lootBoxLastName') || '';
      } catch { return ''; }
    };

    // Save the most recently used name
    const setLastUsedName = (name) => {
      try {
        localStorage.setItem('lootBoxLastName', name);
      } catch {}
    };

    // One-time migration of old global name
    const migrateOldName = () => {
      try {
        const oldName = localStorage.getItem('lootBoxUserName');
        if (oldName && !localStorage.getItem('lootBoxLastName')) {
          localStorage.setItem('lootBoxLastName', oldName);
          const settings = getUserSettings();
          if (!settings.displayName) {
            saveUserSettings({ ...settings, displayName: oldName });
          }
          localStorage.removeItem('lootBoxUserName');
        }
      } catch {}
    };

    const canCreateLocalBox = () => {
      const settings = getUserSettings();
      if (settings.tier === 'paid') return true;
      
      const MAX_FREE_BOXES = 5;
      const boxes = getAllBoxes();
      const currentCount = boxes.filter(box => box.type === 'local').length;
      return currentCount < MAX_FREE_BOXES;
    };

    // ========== FIREBASE BOX CATALOG SERVICE ==========

    // Fetch default boxes from Firebase
    const fetchDefaultBoxes = async () => {
      if (!firebaseEnabled || !db) return [];
      try {
        // Single-field query to avoid needing a composite Firestore index.
        // Filter out inactive boxes client-side instead.
        const snapshot = await db.collection('boxCatalog')
          .where('source', '==', BOX_SOURCES.DEFAULT)
          .get();
        return snapshot.docs
          .map(doc => ({
            id: doc.id,
            ...doc.data()
          }))
          .filter(box => box.active !== false);  // Include boxes where active is true, undefined, or missing
      } catch (error) {
        console.error('Error fetching default boxes:', error);
        return [];
      }
    };

    // Fetch premium boxes from Firebase
    const fetchPremiumBoxes = async () => {
      if (!firebaseEnabled || !db) return [];
      try {
        const snapshot = await db.collection('boxCatalog')
          .where('source', '==', BOX_SOURCES.PREMIUM)
          .get();
        return snapshot.docs
          .map(doc => ({
            id: doc.id,
            ...doc.data()
          }))
          .filter(box => box.active !== false);
      } catch (error) {
        console.error('Error fetching premium boxes:', error);
        return [];
      }
    };

    // Fetch seasonal boxes from Firebase
    const fetchSeasonalBoxes = async () => {
      if (!firebaseEnabled || !db) return [];

      try {
        const snapshot = await db.collection('boxCatalog')
          .where('source', '==', BOX_SOURCES.SEASONAL)
          .get();

        const now = Date.now();

        // Filter expired boxes client-side to avoid needing a Firestore index
        return snapshot.docs
          .map(doc => ({
            id: doc.id,
            ...doc.data()
          }))
          .filter(box => {
            // Only show boxes that haven't expired
            return !box.seasonalInfo?.endDate || box.seasonalInfo.endDate > now;
          });
      } catch (error) {
        console.error('Error fetching seasonal boxes:', error);
        return [];
      }
    };

    // Fetch store boxes from Firebase
    const fetchStoreBoxes = async () => {
      if (!firebaseEnabled || !db) return [];

      try {
        const snapshot = await db.collection('boxCatalog')
          .where('source', '==', BOX_SOURCES.STORE)
          .get();

        return snapshot.docs
          .map(doc => ({
            id: doc.id,
            ...doc.data()
          }))
          .filter(box => box.active !== false);
      } catch (error) {
        console.error('Error fetching store boxes:', error);
        return [];
      }
    };

    // Fetch user's uploaded boxes from Firebase
    const fetchUserUploadedBoxes = async (userId) => {
      if (!firebaseEnabled || !db || !userId) return [];

      try {
        const snapshot = await db.collection('boxCatalog')
          .where('source', '==', BOX_SOURCES.USER_UPLOADED)
          .where('userId', '==', userId)
          .get();

        return snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      } catch (error) {
        console.error('Error fetching user uploaded boxes:', error);
        return [];
      }
    };

    // Upload user's custom box image to Firebase
    const uploadUserBox = async (imageFile, metadata, userId) => {
      if (!firebaseEnabled || !storage || !db) {
        throw new Error('Firebase not available');
      }

      if (!userId) {
        throw new Error('User not authenticated');
      }

      try {
        // Upload image to Firebase Storage
        const storageRef = storage.ref();
        const fileName = `user-boxes/${userId}/${Date.now()}_${imageFile.name}`;
        const imageRef = storageRef.child(fileName);

        const uploadTask = await imageRef.put(imageFile);
        const downloadURL = await uploadTask.ref.getDownloadURL();

        // Create Firestore document
        const boxData = {
          name: metadata.name || 'Custom Box',
          source: BOX_SOURCES.USER_UPLOADED,
          userId: userId,
          imageUrl: downloadURL,
          price: null,
          seasonalInfo: null,
          createdAt: Date.now(),
          active: true
        };

        const docRef = await db.collection('boxCatalog').add(boxData);

        return {
          id: docRef.id,
          ...boxData
        };
      } catch (error) {
        console.error('Error uploading box:', error);
        throw error;
      }
    };

    // Get all available box images (unified loader)
    const getAllAvailableBoxImages = async (userSettings) => {
      let defaults = [];
      let seasonal = [];
      let store = [];
      let premium = [];
      let userUploaded = [];

      if (firebaseEnabled) {
        // Fetch all sources from Firebase in parallel
        const results = await Promise.all([
          fetchDefaultBoxes(),
          fetchSeasonalBoxes(),
          fetchStoreBoxes(),
          userSettings.tier === 'paid'
            ? fetchPremiumBoxes()
            : Promise.resolve([]),
          userSettings.tier === 'paid' && userSettings.uid
            ? fetchUserUploadedBoxes(userSettings.uid)
            : Promise.resolve([])
        ]);

        defaults = results[0];
        seasonal = results[1];
        store = results[2];
        premium = results[3];
        userUploaded = results[4];

        console.log('[BoxCatalog] Loaded from Firebase:', {
          defaults: defaults.length,
          seasonal: seasonal.length,
          store: store.length,
          premium: premium.length,
          userUploaded: userUploaded.length,
        });
      }

      // Fall back to hardcoded defaults ONLY if Firebase
      // returned nothing (offline, not configured, etc.)
      if (defaults.length === 0) {
        defaults = getDefaultBoxImages();
      }

      return {
        defaults,
        seasonal,
        store,
        premium,
        userUploaded,
        all: [...defaults, ...seasonal, ...store, ...premium, ...userUploaded]
      };
    };

    // Purchase a box from the store
    const purchaseBox = async (boxId, userId) => {
      if (!firebaseEnabled || !db) {
        throw new Error('Firebase not available');
      }

      try {
        // Record purchase in Firestore
        await db.collection('purchases').add({
          boxId: boxId,
          userId: userId,
          purchasedAt: Date.now(),
          type: 'box'
        });

        // Update user's owned boxes
        const userRef = db.collection('users').doc(userId);
        await userRef.update({
          ownedBoxes: firebase.firestore.FieldValue.arrayUnion(boxId)
        });

        return true;
      } catch (error) {
        console.error('Error purchasing box:', error);
        throw error;
      }
    };

    // Check if user owns a box
    const userOwnsBox = (boxId, userSettings) => {
      // Hardcoded default boxes are always available
      const hardcodedDefault = DEFAULT_BOX_IMAGES.find(b => b.id === boxId);
      if (hardcodedDefault) return true;

      // User's own uploaded boxes
      if (userSettings.uploadedBoxes && userSettings.uploadedBoxes.includes(boxId)) return true;

      // Individually purchased boxes
      if (userSettings.ownedBoxes && userSettings.ownedBoxes.includes(boxId)) return true;

      // NOTE: Firebase default boxes and premium boxes are handled
      // by canUserUseBox in the ImagePicker component, not here.
      // This function is for ownership checks only.

      return false;
    };

    // ========== FIRESTORE FUNCTIONS FOR SHARED BOXES ==========

    // Save a shared box to Firestore
    const saveSharedBox = async (box) => {
      if (!firebaseEnabled || !db) {
        throw new Error('Firebase not available');
      }
      try {
        await db.collection('sharedBoxes').doc(box.shareCode).set({
          ...box,
          updatedAt: Date.now()
        });
        return true;
      } catch (error) {
        console.error('Error saving shared box:', error);
        throw error;
      }
    };

    // Fetch a shared box by share code
    const fetchSharedBox = async (shareCode) => {
      if (!firebaseEnabled || !db) return null;
      try {
        const doc = await db.collection('sharedBoxes').doc(shareCode).get();
        if (doc.exists) {
          return { id: doc.id, ...doc.data() };
        }
        return null;
      } catch (error) {
        console.error('Error fetching shared box:', error);
        return null;
      }
    };

    // Add a pull to a shared box in Firestore
    const addPullToSharedBox = async (shareCode, pull) => {
      if (!firebaseEnabled || !db) {
        throw new Error('Firebase not available');
      }
      try {
        const boxRef = db.collection('sharedBoxes').doc(shareCode);

        await db.runTransaction(async (transaction) => {
          const doc = await transaction.get(boxRef);
          if (!doc.exists) {
            throw new Error('Shared box not found');
          }

          const data = doc.data();
          const history = data.pullHistory || [];

          // Server-side total limit check
          if (data.maxPulls && history.length >= data.maxPulls) {
            throw new Error('Box has reached maximum opens');
          }

          // Server-side per-user limit check
          if (data.maxPullsPerUser && pull.deviceId) {
            const userPulls = history.filter(p => p.deviceId === pull.deviceId).length;
            if (userPulls >= data.maxPullsPerUser) {
              throw new Error('You have reached your open limit for this box');
            }
          }

          // All checks passed - append the pull
          transaction.update(boxRef, {
            pullHistory: [...history, pull],
            updatedAt: Date.now()
          });
        });

        return true;
      } catch (error) {
        console.error('Error adding pull:', error);
        throw error;
      }
    };

    // Listen to real-time updates on a shared box
    const subscribeToSharedBox = (shareCode, callback) => {
      if (!firebaseEnabled || !db) return () => {};
      return db.collection('sharedBoxes').doc(shareCode).onSnapshot((doc) => {
        if (doc.exists) {
          callback({ id: doc.id, ...doc.data() });
        } else {
          callback(null);
        }
      }, (error) => {
        console.error('Error in shared box listener:', error);
      });
    };

    // Delete a shared box from Firestore
    const deleteSharedBox = async (shareCode) => {
      if (!firebaseEnabled || !db) return false;
      try {
        await db.collection('sharedBoxes').doc(shareCode).delete();
        return true;
      } catch (error) {
        console.error('Error deleting shared box from Firestore:', error);
        return false;
      }
    };

    // ========== BOX TEMPLATES ==========

    const saveBoxTemplate = async (box) => {
      if (!firebaseEnabled || !db) return null;
      try {
        const shareCode = generateShareCode();
        const templateData = {
          templateId: shareCode,
          name: box.name,
          items: (box.items || []).map(item => ({
            id: item.id,
            name: item.name,
            percentage: item.percentage,
            color: item.color,
            maxQuantity: item.maxQuantity || null,
            imageUrl: item.imageUrl || null,
          })),
          boxImageId: box.boxImageId || null,
          hideContents: box.hideContents || false,
          hideOdds: box.hideOdds || false,
          maxPulls: box.maxPulls || null,
          createdBy: getUserSettings().displayName || 'Anonymous',
          createdAt: Date.now(),
          shareCode: shareCode,
          expiresAt: null,
        };
        await db.collection('boxTemplates').doc(shareCode).set(templateData);
        return shareCode;
      } catch (error) {
        console.error('Error saving box template:', error);
        return null;
      }
    };

    const fetchBoxTemplate = async (shareCode) => {
      if (!firebaseEnabled || !db) return null;
      try {
        const doc = await db.collection('boxTemplates').doc(shareCode).get();
        if (doc.exists) {
          return doc.data();
        }
        return null;
      } catch (error) {
        console.error('Error fetching box template:', error);
        return null;
      }
    };

    const importBoxFromTemplate = (templateData) => {
      const newBox = {
        id: Date.now().toString(),
        name: templateData.name,
        items: templateData.items || [],
        boxImageId: templateData.boxImageId || null,
        hideContents: templateData.hideContents || false,
        hideOdds: templateData.hideOdds || false,
        maxPulls: templateData.maxPulls || null,
        pullHistory: [],
        type: 'local',
        createdAt: Date.now(),
        templateSource: {
          name: templateData.createdBy,
          shareCode: templateData.shareCode,
        },
      };
      saveBox(newBox);
      return newBox;
    };

    // ========== COMPONENTS - COMMON ==========
    
    // Button Component
    const Button = ({ children, onClick, variant = 'primary', size = 'md', disabled = false, fullWidth = false, style = {} }) => {
      const [isHovered, setIsHovered] = useState(false);

      const variants = {
        primary: {
          background: 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
          color: '#ffffff',
          boxShadow: '0 4px 16px rgba(30, 64, 175, 0.4)',
        },
        secondary: {
          background: 'linear-gradient(135deg, #2563eb 0%, #60a5fa 100%)',
          color: '#ffffff',
          boxShadow: '0 4px 16px rgba(37, 99, 235, 0.4)',
        },
        ghost: {
          background: 'rgba(26, 31, 53, 0.6)',
          color: '#cbd5e1',
          border: '1px solid rgba(59, 130, 246, 0.2)',
        },
      };

      const sizes = {
        sm: { padding: '0.5rem 1rem', fontSize: '0.875rem' },
        md: { padding: '0.75rem 1.5rem', fontSize: '1rem' },
        lg: { padding: '1rem 2rem', fontSize: '1.125rem' },
      };

      const baseStyles = {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '0.5rem',
        border: 'none',
        borderRadius: '12px',
        fontFamily: 'inherit',
        fontWeight: 600,
        cursor: disabled ? 'not-allowed' : 'pointer',
        transition: 'all 0.25s ease',
        width: fullWidth ? '100%' : 'auto',
        opacity: disabled ? 0.6 : 1,
        filter: disabled ? 'saturate(0.5)' : 'none',
        ...variants[variant],
        ...sizes[size],
        ...(isHovered && !disabled ? { transform: 'translateY(-2px)' } : {}),
        ...style,
      };

      return (
        <button
          style={baseStyles}
          onClick={disabled ? undefined : onClick}
          onMouseEnter={() => setIsHovered(true)}
          onMouseLeave={() => setIsHovered(false)}
          disabled={disabled}
        >
          {children}
        </button>
      );
    };

    // Input Component  
    const Input = ({ type = 'text', value, onChange, placeholder = '', label = '', fullWidth = false, ...props }) => {
      const [isFocused, setIsFocused] = useState(false);

      const containerStyles = {
        display: 'flex',
        flexDirection: 'column',
        gap: '0.5rem',
        width: fullWidth ? '100%' : 'auto',
      };

      const inputStyles = {
        width: '100%',
        padding: '12px 16px',
        fontSize: '1rem',
        fontFamily: 'inherit',
        color: '#e2e8f0',
        background: 'rgba(30, 41, 59, 0.8)',
        border: `1.5px solid ${isFocused ? 'rgba(65, 105, 225, 0.6)' : 'rgba(65, 105, 225, 0.35)'}`,
        borderRadius: '12px',
        outline: 'none',
        transition: 'all 0.2s ease',
        boxShadow: isFocused
          ? '0 0 12px rgba(65, 105, 225, 0.25), inset 0 1px 2px rgba(0, 0, 0, 0.2)'
          : '0 0 8px rgba(65, 105, 225, 0.1), inset 0 1px 2px rgba(0, 0, 0, 0.2)',
      };

      return (
        <div style={containerStyles}>
          {label && <label style={{ fontSize: '0.875rem', fontWeight: 500, color: '#cbd5e1' }}>{label}</label>}
          <input
            type={type}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            style={inputStyles}
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
            {...props}
          />
        </div>
      );
    };

    // Card Component
    const Card = ({ children, hover = false, onClick, style = {} }) => {
      const [isHovered, setIsHovered] = useState(false);

      const baseStyles = {
        background: 'rgba(26, 31, 53, 0.6)',
        backdropFilter: 'blur(12px)',
        border: '1px solid rgba(59, 130, 246, 0.2)',
        borderRadius: '16px',
        padding: '1.5rem',
        transition: 'all 0.3s ease',
        cursor: onClick ? 'pointer' : 'default',
        ...(hover && isHovered ? {
          transform: 'translateY(-4px)',
          borderColor: '#3b82f6',
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
        } : {}),
        ...style,
      };

      return (
        <div
          style={baseStyles}
          onMouseEnter={() => setIsHovered(true)}
          onMouseLeave={() => setIsHovered(false)}
          onClick={onClick}
        >
          {children}
        </div>
      );
    };

    // Toast Component
    const Toast = ({ message, type = 'info', duration = 3000, onClose, show = false }) => {
      if (!show) return null;

      const types = {
        success: { background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.9) 0%, rgba(5, 150, 105, 0.9) 100%)', icon: '✓' },
        error: { background: 'linear-gradient(135deg, rgba(239, 68, 68, 0.9) 0%, rgba(220, 38, 38, 0.9) 100%)', icon: '✕' },
        info: { background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.9) 0%, rgba(37, 99, 235, 0.9) 100%)', icon: 'ℹ' },
      };

      const typeStyle = types[type] || types.info;

      const containerStyles = {
        position: 'fixed',
        bottom: '2rem',
        left: '50%',
        transform: 'translate(-50%, 0)',
        zIndex: 9999,
        display: 'flex',
        alignItems: 'center',
        gap: '1rem',
        padding: '1rem 1.5rem',
        background: typeStyle.background,
        backdropFilter: 'blur(12px)',
        borderRadius: '12px',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
        color: '#ffffff',
        fontWeight: 500,
        minWidth: '300px',
        animation: 'toastSlideUp 0.4s ease',
      };

      return (
        <div style={containerStyles}>
          <span style={{ fontSize: '1.25rem' }}>{typeStyle.icon}</span>
          <span>{message}</span>
          <button
            style={{
              marginLeft: 'auto',
              background: 'none',
              border: 'none',
              color: '#ffffff',
              fontSize: '1.25rem',
              cursor: 'pointer',
              opacity: 0.7,
            }}
            onClick={onClose}
          >
            ×
          </button>
        </div>
      );
    };

    // useIsMobile Hook
    const useIsMobile = (breakpoint = 768) => {
      const [isMobile, setIsMobile] = useState(window.innerWidth < breakpoint);
      useEffect(() => {
        const handleResize = () => setIsMobile(window.innerWidth < breakpoint);
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, [breakpoint]);
      return isMobile;
    };

    // useToast Hook
    const useToast = () => {
      const [toast, setToast] = useState(null);
      const toastTimeoutRef = useRef(null);
      const toastKeyRef = useRef(0);

      const showToast = (message, type = 'info', duration = 3000) => {
        if (toastTimeoutRef.current) {
          clearTimeout(toastTimeoutRef.current);
        }
        setToast(null);
        requestAnimationFrame(() => {
          toastKeyRef.current += 1;
          setToast({ message, type, duration, key: toastKeyRef.current });
          toastTimeoutRef.current = setTimeout(() => {
            setToast(null);
          }, duration);
        });
      };

      const toastElement = toast ? (
        <Toast
          key={toast.key}
          message={toast.message}
          type={toast.type}
          duration={toast.duration}
          show={true}
          onClose={() => {
            if (toastTimeoutRef.current) clearTimeout(toastTimeoutRef.current);
            setToast(null);
          }}
        />
      ) : null;

      return {
        showToast,
        toastElement,
        success: (message, duration) => showToast(message, 'success', duration),
        error: (message, duration) => showToast(message, 'error', duration),
        info: (message, duration) => showToast(message, 'info', duration),
      };
    };

    // ========== COMPONENTS - LAYOUT ==========

    // AboutModal
    const AboutModal = ({ show, onClose }) => {
      if (!show) return null;
      return (
        <div style={{
          position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
          background: 'rgba(0,0,0,0.6)', backdropFilter: 'blur(4px)',
          zIndex: 10000, display: 'flex', alignItems: 'center', justifyContent: 'center',
          padding: '1rem',
        }} onClick={onClose}>
          <div style={{
            background: 'linear-gradient(180deg, #0f172a 0%, #1e293b 100%)',
            border: '1px solid rgba(59, 130, 246, 0.2)',
            borderRadius: '16px',
            padding: '2rem',
            maxWidth: '360px',
            width: '100%',
            textAlign: 'center',
          }} onClick={e => e.stopPropagation()}>
            <div style={{ fontSize: '1.5rem', fontWeight: 700, color: '#e2e8f0', marginBottom: '0.25rem' }}>
              Loot Box Creator
            </div>
            <div style={{ fontSize: '0.85rem', color: '#64748b', marginBottom: '1rem' }}>v1.0.0</div>
            <div style={{ fontSize: '0.9rem', color: '#94a3b8', marginBottom: '1.5rem', lineHeight: 1.5 }}>
              Create, customize, and share loot boxes with friends. Built with love.
            </div>
            <div style={{ height: '1px', background: 'rgba(59, 130, 246, 0.15)', marginBottom: '1rem' }} />
            <div style={{ fontSize: '0.8rem', color: '#64748b', marginBottom: '0.5rem' }}>Powered by Firebase</div>
            <button onClick={onClose} style={{
              marginTop: '1rem', padding: '0.75rem 2rem',
              background: 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
              border: 'none', borderRadius: '10px', color: '#fff',
              fontWeight: 600, cursor: 'pointer', fontFamily: 'inherit', fontSize: '0.9rem',
            }}>Close</button>
          </div>
        </div>
      );
    };

    // SideDrawer
    const SideDrawer = ({ isOpen, onClose, userSettings, onNavigate }) => {
      const menuItems = [
        { key: 'myBoxes', label: 'My Boxes', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" />
            <rect x="3" y="14" width="7" height="7" /><rect x="14" y="14" width="7" height="7" />
          </svg>
        )},
        { key: 'marketplace', label: 'Marketplace', badge: 'Soon', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M6 2L3 6v14a2 2 0 002 2h14a2 2 0 002-2V6l-3-4z" />
            <line x1="3" y1="6" x2="21" y2="6" /><path d="M16 10a4 4 0 01-8 0" />
          </svg>
        )},
        { key: 'templates', label: 'Box Templates', badge: 'Soon', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
            <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" />
          </svg>
        )},
        { key: 'stats', label: 'Stats', badge: 'Soon', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <line x1="12" y1="20" x2="12" y2="10" /><line x1="18" y1="20" x2="18" y2="4" />
            <line x1="6" y1="20" x2="6" y2="16" />
          </svg>
        )},
        'divider',
        { key: 'account', label: 'My Account', badge: 'Soon', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2" /><circle cx="12" cy="7" r="4" />
          </svg>
        )},
        { key: 'settings', label: 'Settings', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="12" cy="12" r="3" />
            <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09a1.65 1.65 0 00-1-1.51 1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09a1.65 1.65 0 001.51-1 1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06a1.65 1.65 0 001.82.33h.09a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06a1.65 1.65 0 00-.33 1.82v.09a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z" />
          </svg>
        )},
        'divider',
        { key: 'shareApp', label: 'Share the App', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="18" cy="5" r="3" /><circle cx="6" cy="12" r="3" /><circle cx="18" cy="19" r="3" />
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49" />
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49" />
          </svg>
        )},
        { key: 'about', label: 'About', icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="12" cy="12" r="10" />
            <line x1="12" y1="16" x2="12" y2="12" /><line x1="12" y1="8" x2="12.01" y2="8" />
          </svg>
        )},
        'divider',
        { key: 'toggleTier', label: 'Toggle Tier', tierIndicator: true, icon: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M14.7 6.3a1 1 0 000 1.4l1.6 1.6a1 1 0 001.4 0l3.77-3.77a6 6 0 01-7.94 7.94l-6.91 6.91a2.12 2.12 0 01-3-3l6.91-6.91a6 6 0 017.94-7.94l-3.76 3.76z" />
          </svg>
        )},
      ];

      const displayName = userSettings?.displayName || 'Loot Box User';
      const isPremium = userSettings?.tier === 'paid';

      return (
        <>
          {/* Overlay */}
          <div style={{
            position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
            background: 'rgba(0, 0, 0, 0.6)',
            backdropFilter: 'blur(4px)',
            zIndex: 9998,
            opacity: isOpen ? 1 : 0,
            pointerEvents: isOpen ? 'auto' : 'none',
            transition: 'opacity 0.3s ease',
          }} onClick={onClose} />

          {/* Drawer */}
          <div style={{
            position: 'fixed', top: 0, left: 0, bottom: 0,
            width: 'min(280px, 80%)',
            maxWidth: '320px',
            background: 'linear-gradient(180deg, #0f172a 0%, #1e293b 100%)',
            borderRight: '1px solid rgba(65, 105, 225, 0.2)',
            zIndex: 9999,
            transform: isOpen ? 'translateX(0)' : 'translateX(-100%)',
            transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            overflowY: 'auto',
            boxShadow: isOpen ? '4px 0 24px rgba(0, 0, 0, 0.5)' : 'none',
            display: 'flex',
            flexDirection: 'column',
          }}>
            {/* Header */}
            <div style={{
              padding: '24px 20px',
              borderBottom: '1px solid rgba(65, 105, 225, 0.15)',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              position: 'relative',
            }}>
              <div style={{
                width: '44px', height: '44px', borderRadius: '50%',
                background: 'linear-gradient(135deg, #4169e1, #1e40af)',
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                fontSize: '18px', fontWeight: 700, color: '#fff',
                flexShrink: 0,
              }}>
                {displayName.charAt(0).toUpperCase()}
              </div>
              <div style={{ flex: 1, minWidth: 0 }}>
                <div style={{ fontWeight: 700, color: '#e2e8f0', fontSize: '1rem', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                  {displayName}
                </div>
                <span style={{
                  display: 'inline-block',
                  marginTop: '4px',
                  padding: '2px 8px',
                  borderRadius: '10px',
                  fontSize: '0.65rem',
                  fontWeight: 700,
                  textTransform: 'uppercase',
                  letterSpacing: '0.05em',
                  ...(isPremium
                    ? { background: 'linear-gradient(135deg, #f59e0b, #ec4899)', color: '#fff' }
                    : { background: 'rgba(100, 116, 139, 0.3)', color: '#94a3b8' }
                  ),
                }}>
                  {isPremium ? 'Premium' : 'Free'}
                </span>
              </div>
              <button onClick={onClose} style={{
                position: 'absolute', top: '16px', right: '16px',
                background: 'none', border: 'none', cursor: 'pointer', padding: '4px',
                color: '#64748b', display: 'flex',
              }}>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
                  <line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" />
                </svg>
              </button>
            </div>

            {/* Menu Items */}
            <div style={{ flex: 1, padding: '8px 0' }}>
              {menuItems.map((item, i) => {
                if (item === 'divider') {
                  return <div key={`div-${i}`} style={{ height: '1px', background: 'rgba(255,255,255,0.06)', margin: '8px 20px' }} />;
                }
                return (
                  <button key={item.key} onClick={() => onNavigate(item.key)} style={{
                    display: 'flex', alignItems: 'center', gap: '14px',
                    width: '100%', padding: '14px 20px',
                    background: 'none', border: 'none', borderBottom: '1px solid rgba(255,255,255,0.05)',
                    color: '#94a3b8', cursor: 'pointer', fontFamily: 'inherit',
                    transition: 'background 0.15s ease',
                    textAlign: 'left',
                  }}
                  onMouseEnter={e => e.currentTarget.style.background = 'rgba(65, 105, 225, 0.1)'}
                  onMouseLeave={e => e.currentTarget.style.background = 'none'}
                  >
                    <span style={{ display: 'flex', flexShrink: 0 }}>{item.icon}</span>
                    <span style={{ flex: 1, color: '#e2e8f0', fontSize: '0.95rem', fontWeight: 500 }}>{item.label}</span>
                    {item.badge && (
                      <span style={{
                        padding: '2px 8px', borderRadius: '10px',
                        fontSize: '0.65rem', fontWeight: 600,
                        background: 'rgba(245, 158, 11, 0.2)', color: '#f59e0b',
                      }}>{item.badge}</span>
                    )}
                    {item.tierIndicator && (
                      <span style={{
                        fontSize: '0.8rem', fontWeight: 600,
                        color: isPremium ? '#f59e0b' : '#94a3b8',
                      }}>{isPremium ? 'Premium' : 'Free'}</span>
                    )}
                  </button>
                );
              })}
            </div>
          </div>
        </>
      );
    };

    // ========== SOUND ENGINE (Web Audio API, zero audio files) ==========
    let _audioCtx = null;

    const _ensureAudio = () => {
      if (!_audioCtx) {
        _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      // Always try to resume - this is the key for iOS
      if (_audioCtx.state === 'suspended') {
        _audioCtx.resume();
      }
      return _audioCtx;
    };

    // Warm up audio on any user interaction (belt and suspenders)
    const _warmUpAudio = () => {
      const ctx = _ensureAudio();
      // Play a silent buffer to fully unlock iOS audio
      try {
        const buffer = ctx.createBuffer(1, 1, 22050);
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(ctx.destination);
        source.start(0);
      } catch(e) {}
    };

    // Rising tension buildup sound (plays during shake phase)
    const playBuildUpSound = () => {
      try {
        const ctx = _ensureAudio();
        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 1.0);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.linearRampToValueAtTime(0.2, now + 0.8);
        gain.gain.linearRampToValueAtTime(0, now + 1.2);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 1.2);
        const bufferSize = ctx.sampleRate * 1.2;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        const noiseGain = ctx.createGain();
        const noiseFilter = ctx.createBiquadFilter();
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.setValueAtTime(800, now);
        noiseFilter.frequency.exponentialRampToValueAtTime(2000, now + 1.0);
        noiseFilter.Q.value = 2;
        noiseGain.gain.setValueAtTime(0.04, now);
        noiseGain.gain.linearRampToValueAtTime(0.12, now + 0.9);
        noiseGain.gain.linearRampToValueAtTime(0, now + 1.2);
        noise.connect(noiseFilter).connect(noiseGain).connect(ctx.destination);
        noise.start(now);
        noise.stop(now + 1.2);
      } catch(e) { console.warn('Sound error:', e); }
    };

    // Sparkly reveal chime (plays on result reveal)
    const playRevealSound = () => {
      try {
        const ctx = _ensureAudio();
        const now = ctx.currentTime;
        [523, 659, 784, 1047].forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, now + i * 0.04);
          gain.gain.linearRampToValueAtTime(0.1, now + i * 0.04 + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.04 + 0.8);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + i * 0.04);
          osc.stop(now + i * 0.04 + 0.8);
        });
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(2000, now);
        osc2.frequency.exponentialRampToValueAtTime(4000, now + 0.3);
        osc2.frequency.exponentialRampToValueAtTime(2000, now + 0.6);
        gain2.gain.setValueAtTime(0.02, now);
        gain2.gain.linearRampToValueAtTime(0.05, now + 0.15);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
        osc2.connect(gain2).connect(ctx.destination);
        osc2.start(now);
        osc2.stop(now + 0.6);
      } catch(e) { console.warn('Sound error:', e); }
    };

    // Epic rare item fanfare (for items with <10% chance)
    const playRareSound = () => {
      try {
        const ctx = _ensureAudio();
        const now = ctx.currentTime;
        const notes = [523, 659, 784, 1047, 1319];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = i < 3 ? 'triangle' : 'sine';
          osc.frequency.value = freq;
          const t = now + i * 0.12;
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.12, t + 0.04);
          gain.gain.setValueAtTime(0.12, t + 0.08);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
          osc.connect(gain).connect(ctx.destination);
          osc.start(t);
          osc.stop(t + 0.5);
        });
        [1047, 1319, 1568].forEach((freq) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          const t = now + 0.6;
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.06, t + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
          osc.connect(gain).connect(ctx.destination);
          osc.start(t);
          osc.stop(t + 1.2);
        });
      } catch(e) { console.warn('Sound error:', e); }
    };

    // Helper: create particle elements and append to a container DOM node
    const spawnParticles = (containerEl, color = '#f59e0b', count = 24) => {
      if (!containerEl) return;
      containerEl.innerHTML = '';
      const rect = containerEl.getBoundingClientRect();
      const cx = rect.width / 2;
      const cy = rect.height / 2;
      for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        const isStar = Math.random() > 0.5;
        const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
        const distance = 80 + Math.random() * 100;
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance;
        const size = 4 + Math.random() * 8;
        const duration = 0.6 + Math.random() * 0.6;
        const delay = Math.random() * 0.15;
        const colors = [color, color, color, '#ffffff', '#fbbf24'];
        const pColor = colors[Math.floor(Math.random() * colors.length)];
        p.style.cssText = `
          position: absolute;
          left: ${cx - size/2}px;
          top: ${cy - size/2}px;
          width: ${size}px;
          height: ${size}px;
          border-radius: ${isStar ? '0' : '50%'};
          ${isStar ? 'clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);' : ''}
          background: ${pColor};
          box-shadow: 0 0 ${size}px ${pColor}80;
          opacity: 0;
          pointer-events: none;
          --tx: ${tx}px;
          --ty: ${ty}px;
          animation: particleBurst ${duration}s ${delay}s ease-out forwards;
        `;
        containerEl.appendChild(p);
      }
    };

    // Header
    const Header = ({ title = 'Loot Box Creator V1137', onMenuClick }) => {
      const isMobile = useIsMobile();
      return (
        <header style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          padding: isMobile ? '1rem' : '1.5rem 0',
          marginBottom: isMobile ? '1rem' : '2rem',
          borderBottom: '1px solid rgba(59, 130, 246, 0.2)',
        }}>
          {/* Hamburger */}
          <button onClick={onMenuClick} style={{
            width: '44px', height: '44px',
            display: 'flex', alignItems: 'center', justifyContent: 'center',
            background: 'none', border: 'none', cursor: 'pointer',
            color: '#e2e8f0', padding: 0, flexShrink: 0,
            marginLeft: '-10px',
          }}>
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
              <line x1="3" y1="6" x2="21" y2="6" />
              <line x1="3" y1="12" x2="21" y2="12" />
              <line x1="3" y1="18" x2="21" y2="18" />
            </svg>
          </button>

          {/* Title */}
          <h1 style={{
            fontSize: isMobile ? '1.5rem' : '2.5rem',
            fontWeight: 700,
            background: 'linear-gradient(135deg, #3b82f6 0%, #60a5fa 50%, #93c5fd 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            filter: 'drop-shadow(0 0 30px rgba(59, 130, 246, 0.4))',
            margin: 0,
            textAlign: 'center',
            whiteSpace: 'nowrap',
          }}>
            {title}
          </h1>
          {/* Spacer to balance hamburger for centered title */}
          <div style={{ width: '44px', flexShrink: 0 }} />
        </header>
      );
    };

    // FilterTabs
    const FilterTabs = ({ activeFilter, onFilterChange, filters = ['Shared', 'New', 'Local'] }) => {
      const isMobile = useIsMobile();
      return (
        <div style={{
          display: 'flex',
          gap: '0.25rem',
          padding: '0.5rem',
          background: 'rgba(15, 22, 36, 0.8)',
          borderRadius: '12px',
          border: '1px solid rgba(59, 130, 246, 0.2)',
          marginBottom: '2rem',
          overflow: 'hidden',
        }}>
          {filters.map(filter => {
            const isActive = activeFilter === filter;
            return (
              <button
                key={filter}
                style={{
                  flex: 1,
                  padding: '0.75rem 0.5rem',
                  fontSize: isMobile ? '0.8rem' : '0.875rem',
                  fontWeight: 600,
                  color: isActive ? '#ffffff' : '#94a3b8',
                  background: isActive ? 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)' : 'transparent',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  transition: 'all 0.25s ease',
                  fontFamily: 'inherit',
                  boxShadow: isActive ? '0 4px 16px rgba(59, 130, 246, 0.3)' : 'none',
                }}
                onClick={() => onFilterChange(filter)}
              >
                {filter}
              </button>
            );
          })}
        </div>
      );
    };

    // ConfirmDialog Component
    const ConfirmDialog = ({ show, title, message, onConfirm, onCancel, confirmText = 'Delete', cancelText = 'Cancel' }) => {
      if (!show) return null;

      return (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'rgba(0, 0, 0, 0.7)',
          backdropFilter: 'blur(4px)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 9999,
          animation: 'fadeIn 0.2s ease',
        }}>
          <Card style={{
            maxWidth: '400px',
            width: '90%',
            animation: 'slideUp 0.3s ease',
          }}>
            <h3 style={{
              fontSize: '1.5rem',
              fontWeight: 700,
              color: '#e2e8f0',
              marginBottom: '1rem',
            }}>
              {title}
            </h3>
            <p style={{
              fontSize: '1rem',
              color: '#94a3b8',
              marginBottom: '1.5rem',
              lineHeight: 1.6,
            }}>
              {message}
            </p>
            <div style={{ display: 'flex', gap: '1rem' }}>
              <Button variant="ghost" onClick={onCancel} fullWidth>
                {cancelText}
              </Button>
              <Button variant="secondary" onClick={onConfirm} fullWidth style={{
                background: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
              }}>
                {confirmText}
              </Button>
            </div>
          </Card>
        </div>
      );
    };

    // SettingsModal Component
    const SettingsModal = ({ show, onClose, userSettings, onSave }) => {
      const [displayName, setDisplayName] = useState(userSettings.displayName || '');
      const isMobile = useIsMobile();

      if (!show) return null;

      const handleSave = () => {
        onSave({ ...userSettings, displayName: displayName.trim() });
        onClose();
      };

      return (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'rgba(0, 0, 0, 0.7)',
          backdropFilter: 'blur(4px)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 9999,
          animation: 'fadeIn 0.2s ease',
        }}>
          <Card style={{
            maxWidth: '400px',
            width: '90%',
            animation: 'slideUp 0.3s ease',
          }}>
            <h3 style={{
              fontSize: '1.5rem',
              fontWeight: 700,
              color: '#e2e8f0',
              marginBottom: '1.5rem',
            }}>
              Settings
            </h3>

            <Input
              label="Display Name"
              placeholder="Enter your name"
              value={displayName}
              onChange={(e) => setDisplayName(e.target.value)}
              fullWidth
              style={{ fontSize: '16px' }}
            />
            <div style={{
              fontSize: '0.75rem',
              color: '#94a3b8',
              marginTop: '0.25rem',
              marginBottom: '1.5rem',
            }}>
              Used for solo boxes and as the default for new group boxes.
            </div>

            <div style={{ display: 'flex', gap: '1rem' }}>
              <Button variant="ghost" onClick={onClose} fullWidth>
                Cancel
              </Button>
              <Button variant="primary" onClick={handleSave} fullWidth>
                Save
              </Button>
            </div>
          </Card>
        </div>
      );
    };

    // BoxCard (simplified for brevity)
    const BoxCard = ({ box, onClick, onEdit, onDelete, success, isNew, isFav, onToggleFavorite }) => {
      const isMobile = useIsMobile();
      const { name, items = [], pullHistory = [], maxPulls, maxPullsPerUser, type = 'local' } = box;
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [activeTooltip, setActiveTooltip] = useState(null);
      const boxFavId = box.shareCode || box.id;

      const handleIconTap = (e, iconId) => {
        e.stopPropagation();
        e.nativeEvent.stopImmediatePropagation();
        setActiveTooltip(activeTooltip === iconId ? null : iconId);
      };

      useEffect(() => {
        if (activeTooltip) {
          const timer = setTimeout(() => setActiveTooltip(null), 3000);
          return () => clearTimeout(timer);
        }
      }, [activeTooltip]);

      // Dismiss tooltip on outside click
      useEffect(() => {
        if (activeTooltip) {
          const dismiss = () => setActiveTooltip(null);
          document.addEventListener('click', dismiss);
          return () => document.removeEventListener('click', dismiss);
        }
      }, [activeTooltip]);

      // Compute opens info
      const opensRemaining = (() => {
        if (!maxPulls || maxPulls <= 0) return { unlimited: true };
        const used = pullHistory.length;
        const remaining = Math.max(0, maxPulls - used);
        return { unlimited: false, remaining, total: maxPulls };
      })();

      const opensIconColor = (() => {
        if (opensRemaining.unlimited) return '#94a3b8';
        if (opensRemaining.remaining <= 0) return '#ef4444';
        if (opensRemaining.remaining <= 2) return '#ef4444';
        const pct = opensRemaining.remaining / opensRemaining.total;
        if (pct <= 0.5) return '#f59e0b';
        return '#10b981';
      })();

      const opensDepleted = !opensRemaining.unlimited && opensRemaining.remaining <= 0;

      const opensValueText = (() => {
        if (opensRemaining.unlimited) return '\u221E';
        return `${pullHistory.length}/${opensRemaining.total}`;
      })();

      const opensTooltipText = (() => {
        if (opensRemaining.unlimited) return 'Unlimited opens available';
        if (opensRemaining.remaining <= 0) return `${pullHistory.length} out of ${opensRemaining.total} opens used`;
        return `${pullHistory.length} out of ${opensRemaining.total} opens used`;
      })();

      // Expiration color
      const expirationIconColor = (() => {
        if (!box.expiresAt) return '#94a3b8';
        const diff = box.expiresAt - Date.now();
        if (diff <= 0) return '#ef4444';
        if (diff <= 60 * 60 * 1000) return '#ef4444';
        if (diff <= 24 * 60 * 60 * 1000) return '#f59e0b';
        return '#94a3b8';
      })();

      const expirationPulse = box.expiresAt && (box.expiresAt - Date.now()) <= 60 * 60 * 1000 && (box.expiresAt - Date.now()) > 0;

      // Shared box participant count
      const uniqueParticipants = (() => {
        if (box.type !== 'shared') return 0;
        const seen = new Set();
        (pullHistory || []).forEach(p => {
          if (p.userName) seen.add(p.userName);
          else if (p.deviceId) seen.add(p.deviceId);
        });
        return seen.size;
      })();

      // Your opens (per-person usage for current user)
      const yourOpensUsed = (() => {
        if (!maxPullsPerUser || maxPullsPerUser <= 0) return 0;
        const myDeviceId = getDeviceId();
        return (pullHistory || []).filter(p => p.deviceId === myDeviceId).length;
      })();

      const yourOpensRemaining = maxPullsPerUser ? Math.max(0, maxPullsPerUser - yourOpensUsed) : 0;

      const yourOpensColor = (() => {
        if (!maxPullsPerUser || maxPullsPerUser <= 0) return '#ec4899';
        if (yourOpensUsed === 0) return '#10b981';
        if (yourOpensUsed >= maxPullsPerUser) return '#ef4444';
        return '#ec4899';
      })();

      const yourOpensDepleted = maxPullsPerUser > 0 && yourOpensUsed >= maxPullsPerUser;

      const isExpired = box.expiresAt ? Date.now() > box.expiresAt : false;

      // Tooltip renderer
      const renderTooltip = (text) => (
        React.createElement('div', {
          style: {
            position: 'absolute',
            bottom: '100%',
            left: '0',
            marginBottom: '6px',
            willChange: 'transform, opacity',
            background: 'rgba(15, 23, 42, 0.95)',
            border: '1px solid rgba(65, 105, 225, 0.3)',
            borderRadius: '8px',
            padding: '8px 12px',
            color: '#e2e8f0',
            fontSize: '0.75rem',
            fontWeight: 500,
            whiteSpace: 'normal',
            maxWidth: '160px',
            zIndex: 10,
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.4)',
            animation: 'fadeIn 0.15s ease',
            pointerEvents: 'none',
          }
        },
          React.createElement('div', {
            style: {
              position: 'absolute',
              bottom: '-6px',
              left: '12px',
              width: 0,
              height: 0,
              borderLeft: '6px solid transparent',
              borderRight: '6px solid transparent',
              borderTop: '6px solid rgba(15, 23, 42, 0.95)',
            }
          }),
          text
        )
      );

      const handleEdit = (e) => {
        e.stopPropagation();
        onEdit && onEdit(box);
      };

      const handleDeleteClick = (e) => {
        e.stopPropagation();
        setShowDeleteConfirm(true);
      };

      const handleShare = async (e) => {
        e.stopPropagation();

        let url;
        if (box.type === 'local') {
          const shareCode = await saveBoxTemplate(box);
          if (!shareCode) {
            success && success('Failed to share box');
            return;
          }
          url = `${window.location.origin}${window.location.pathname}#/template/${shareCode}`;
        } else {
          if (!box.shareCode) return;
          url = `${window.location.origin}${window.location.pathname}#/box/${box.shareCode}`;
        }

        if (navigator.share) {
          try {
            await navigator.share({
              title: box.name,
              text: `Check out my loot box "${box.name}"!`,
              url: url,
            });
          } catch (err) {
            if (err.name !== 'AbortError') {
              console.error('Share failed:', err);
            }
          }
        } else {
          try {
            await navigator.clipboard.writeText(url);
            success && success('Share link copied!');
          } catch (err) {
            prompt('Copy this link:', url);
          }
        }
      };

      const handleDeleteConfirm = () => {
        setShowDeleteConfirm(false);
        onDelete && onDelete(box.id);
      };

      const handleDeleteCancel = () => {
        setShowDeleteConfirm(false);
      };

      return (
        <>
          <div
            style={{
              background: 'rgba(26, 31, 53, 0.6)',
              border: '1px solid rgba(59, 130, 246, 0.2)',
              borderRadius: '12px',
              overflow: 'hidden',
              transition: 'all 0.25s ease',
              cursor: 'default',
              position: 'relative',
            }}
          >

            {/* Action buttons - HORIZONTAL row, absolute top right */}
            <div
              data-no-open="true"
              onClick={(e) => e.stopPropagation()}
              style={{
                position: 'absolute',
                top: '0.5rem',
                right: '0.5rem',
                display: 'flex',
                flexDirection: 'row',
                gap: '6px',
                zIndex: 3,
              }}
            >
              {/* Favorite */}
              <button onClick={(e) => { e.stopPropagation(); onToggleFavorite && onToggleFavorite(boxFavId); }} style={{
                width: '28px', height: '28px', borderRadius: '7px',
                background: 'rgba(15, 23, 42, 0.75)',
                backdropFilter: 'blur(4px)',
                border: isFav ? '1px solid rgba(245, 158, 11, 0.3)' : '1px solid rgba(148, 163, 184, 0.2)',
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                cursor: 'pointer', transition: 'all 0.2s ease', padding: 0,
              }}>
                <svg width="13" height="13" viewBox="0 0 24 24" fill={isFav ? '#f59e0b' : 'none'} stroke={isFav ? '#f59e0b' : '#94a3b8'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ filter: isFav ? 'drop-shadow(0 0 4px rgba(245, 158, 11, 0.5))' : 'none' }}>
                  <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
                </svg>
              </button>

              {/* Share */}
              <button onClick={(e) => { e.stopPropagation(); handleShare(e); }} style={{
                width: '28px', height: '28px', borderRadius: '7px',
                background: 'rgba(15, 23, 42, 0.75)',
                backdropFilter: 'blur(4px)',
                border: '1px solid rgba(148, 163, 184, 0.2)',
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                cursor: 'pointer', transition: 'all 0.2s ease', padding: 0,
              }}>
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="#60a5fa" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M4 12v8a2 2 0 002 2h12a2 2 0 002-2v-8" />
                  <polyline points="16 6 12 2 8 6" />
                  <line x1="12" y1="2" x2="12" y2="15" />
                </svg>
              </button>

              {/* Edit - only for non-visitor boxes */}
              {!box.isVisitor && (
                <button onClick={(e) => { e.stopPropagation(); handleEdit(e); }} style={{
                  width: '28px', height: '28px', borderRadius: '7px',
                  background: 'rgba(15, 23, 42, 0.75)',
                  backdropFilter: 'blur(4px)',
                  border: '1px solid rgba(148, 163, 184, 0.2)',
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  cursor: 'pointer', transition: 'all 0.2s ease', padding: 0,
                }}>
                  <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="#60a5fa" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7" />
                    <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z" />
                  </svg>
                </button>
              )}

              {/* Delete/Remove */}
              <button onClick={(e) => { e.stopPropagation(); setShowDeleteConfirm(true); }} style={{
                width: '28px', height: '28px', borderRadius: '7px',
                background: 'rgba(15, 23, 42, 0.75)',
                backdropFilter: 'blur(4px)',
                border: '1px solid rgba(239, 68, 68, 0.2)',
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                cursor: 'pointer', transition: 'all 0.2s ease', padding: 0,
              }}>
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="#ef4444" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <line x1="18" y1="6" x2="6" y2="18" />
                  <line x1="6" y1="6" x2="18" y2="18" />
                </svg>
              </button>
            </div>

            {/* Main card content - HORIZONTAL flex: left info + right chest */}
            <div style={{
              display: 'flex',
              flexDirection: 'row',
              minHeight: isMobile ? '190px' : '210px',
              position: 'relative',
            }}>

              {/* LEFT SIDE: badges, name, info grid */}
              <div
                data-no-open="true"
                onClick={(e) => e.stopPropagation()}
                style={{
                  flex: 1,
                  minWidth: 0,
                  padding: '0.75rem 0 0.75rem 0.85rem',
                  display: 'flex',
                  flexDirection: 'column',
                  zIndex: 2,
                }}
              >
                {/* Status badges */}
                <div style={{
                  display: 'flex',
                  flexDirection: 'row',
                  gap: '0.35rem',
                  flexWrap: 'wrap',
                  marginBottom: '0.35rem',
                }}>
                  {isNew && (
                    <span style={{
                      padding: '0.15rem 0.5rem', borderRadius: '5px',
                      fontSize: '0.55rem', fontWeight: 700, color: '#ffffff',
                      textTransform: 'uppercase', letterSpacing: '0.03em',
                      background: 'rgba(16, 185, 129, 0.9)',
                    }}>NEW</span>
                  )}
                  {box.type === 'shared' && !box.isVisitor && (
                    <span style={{
                      padding: '0.15rem 0.5rem', borderRadius: '5px',
                      fontSize: '0.55rem', fontWeight: 700, color: '#ffffff',
                      textTransform: 'uppercase', letterSpacing: '0.03em',
                      background: 'rgba(139, 92, 246, 0.9)',
                    }}>GROUP</span>
                  )}
                  {box.isVisitor && (
                    <span style={{
                      padding: '0.15rem 0.5rem', borderRadius: '5px',
                      fontSize: '0.55rem', fontWeight: 700, color: '#ffffff',
                      textTransform: 'uppercase', letterSpacing: '0.03em',
                      background: 'rgba(16, 185, 129, 0.9)',
                    }}>JOINED</span>
                  )}
                  {isExpired && (
                    <span style={{
                      padding: '0.15rem 0.5rem', borderRadius: '5px',
                      fontSize: '0.55rem', fontWeight: 700, color: '#ffffff',
                      textTransform: 'uppercase', letterSpacing: '0.03em',
                      background: 'rgba(239, 68, 68, 0.9)',
                    }}>EXPIRED</span>
                  )}
                </div>

                {/* Box name */}
                <div style={{
                  fontSize: '1.05rem',
                  fontWeight: 700,
                  color: '#e2e8f0',
                  marginBottom: '0.6rem',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  paddingRight: '4px',
                }}>
                  {name}
                </div>

                {/* Info icons - 2 COLUMN GRID */}
                <div style={{
                  display: 'grid',
                  gridTemplateColumns: 'auto auto',
                  gap: '6px 10px',
                  justifyContent: 'start',
                  marginTop: 'auto',
                }}>

                  {/* 1. Items */}
                  <div onClick={(e) => { e.stopPropagation(); e.preventDefault(); handleIconTap(e, 'items'); }} style={{
                    position: 'relative', display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', padding: '2px 0',
                  }}>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#94a3b8" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <polygon points="12 2 2 7 12 12 22 7 12 2" />
                      <polyline points="2 17 12 22 22 17" />
                      <polyline points="2 12 12 17 22 12" />
                    </svg>
                    <span style={{ fontSize: '0.65rem', fontWeight: 600, color: '#94a3b8' }}>{items.length}</span>
                    {activeTooltip === 'items' && renderTooltip(`This box has ${items.length} item${items.length === 1 ? '' : 's'} to discover`)}
                  </div>

                  {/* 2. Opens */}
                  <div onClick={(e) => { e.stopPropagation(); e.preventDefault(); handleIconTap(e, 'opens'); }} style={{
                    position: 'relative', display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', padding: '2px 0',
                    opacity: opensDepleted ? 0.5 : 1,
                  }}>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke={opensIconColor} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <path d="M21 16V8a2 2 0 00-1-1.73l-7-4a2 2 0 00-2 0l-7 4A2 2 0 003 8v8a2 2 0 001 1.73l7 4a2 2 0 002 0l7-4A2 2 0 0021 16z" />
                      <polyline points="3.27 6.96 12 12.01 20.73 6.96" />
                      <line x1="12" y1="22.08" x2="12" y2="12" />
                    </svg>
                    <span style={{ fontSize: '0.65rem', fontWeight: 600, color: opensIconColor }}>{opensValueText}</span>
                    {activeTooltip === 'opens' && renderTooltip(opensTooltipText)}
                  </div>

                  {/* 3. Your Opens */}
                  <div onClick={(e) => { e.stopPropagation(); e.preventDefault(); handleIconTap(e, 'youropens'); }} style={{
                    position: 'relative', display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', padding: '2px 0',
                    opacity: (maxPullsPerUser > 0 && yourOpensDepleted) ? 0.5 : 1,
                  }}>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke={maxPullsPerUser > 0 ? yourOpensColor : '#94a3b8'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2" />
                      <circle cx="12" cy="7" r="4" />
                    </svg>
                    <span style={{ fontSize: '0.65rem', fontWeight: 600, color: maxPullsPerUser > 0 ? yourOpensColor : '#94a3b8' }}>
                      {maxPullsPerUser > 0 ? `${yourOpensRemaining}/${maxPullsPerUser}` : '\u221E'}
                    </span>
                    {activeTooltip === 'youropens' && renderTooltip(
                      !maxPullsPerUser || maxPullsPerUser <= 0
                        ? 'Unlimited opens per person'
                        : yourOpensDepleted
                          ? "You've used all your opens"
                          : `You have ${yourOpensRemaining} open${yourOpensRemaining === 1 ? '' : 's'} remaining`
                    )}
                  </div>

                  {/* 4. History count */}
                  <div onClick={(e) => { e.stopPropagation(); e.preventDefault(); handleIconTap(e, 'history'); }} style={{
                    position: 'relative', display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', padding: '2px 0',
                  }}>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#ec4899" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2" />
                      <circle cx="12" cy="7" r="4" />
                    </svg>
                    <span style={{ fontSize: '0.65rem', fontWeight: 600, color: '#ec4899' }}>{pullHistory.length}</span>
                    {activeTooltip === 'history' && renderTooltip(`${pullHistory.length} total open${pullHistory.length === 1 ? '' : 's'} so far`)}
                  </div>

                  {/* 5. Participants (conditional - shared only) */}
                  {box.type === 'shared' && (
                    <div onClick={(e) => { e.stopPropagation(); e.preventDefault(); handleIconTap(e, 'shared'); }} style={{
                      position: 'relative', display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', padding: '2px 0',
                    }}>
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2" />
                        <circle cx="9" cy="7" r="4" />
                        <path d="M23 21v-2a4 4 0 00-3-3.87" />
                        <path d="M16 3.13a4 4 0 010 7.75" />
                      </svg>
                      <span style={{ fontSize: '0.65rem', fontWeight: 600, color: '#3b82f6' }}>{uniqueParticipants}</span>
                      {activeTooltip === 'shared' && renderTooltip(`${uniqueParticipants} ${uniqueParticipants === 1 ? 'person has' : 'people have'} opened this box`)}
                    </div>
                  )}

                  {/* 6. Expiration (conditional) */}
                  {box.expiresAt && (
                    <div onClick={(e) => { e.stopPropagation(); e.preventDefault(); handleIconTap(e, 'expiration'); }} style={{
                      position: 'relative', display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', padding: '2px 0',
                    }}>
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke={expirationIconColor} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{
                        animation: expirationPulse ? 'pulse 2s ease-in-out infinite' : 'none',
                      }}>
                        <circle cx="12" cy="12" r="10" />
                        <polyline points="12 6 12 12 16 14" />
                      </svg>
                      <span style={{ fontSize: '0.65rem', fontWeight: 600, color: expirationIconColor }}>
                        {box.expiresAt - Date.now() <= 0 ? 'Expired' : formatExpirationCountdown(box.expiresAt)}
                      </span>
                      {activeTooltip === 'expiration' && renderTooltip(
                        box.expiresAt - Date.now() <= 0 ? 'This box has expired' : `This box expires in ${formatExpirationCountdown(box.expiresAt)}`
                      )}
                    </div>
                  )}

                </div>
                {/* End info grid */}
              </div>
              {/* End left side */}

              {/* RIGHT SIDE: chest image - bottom aligned */}
              <div
                data-open-target="true"
                onClick={(e) => {
                  e.stopPropagation();
                  onClick(e);
                }}
                style={{
                  width: '180px',
                  flexShrink: 0,
                  display: 'flex',
                  alignItems: 'flex-end',
                  justifyContent: 'center',
                  cursor: 'pointer',
                  position: 'relative',
                }}
              >
                {box.boxImageId ? (
                  <img
                    src={getBoxImageUrl(box.boxImageId)}
                    alt={box.name}
                    style={{
                      maxWidth: '100%',
                      maxHeight: '90%',
                      objectFit: 'contain',
                      filter: 'drop-shadow(0 4px 16px rgba(0, 0, 0, 0.5))',
                      transition: 'transform 0.2s ease',
                    }}
                  />
                ) : (
                  <span style={{ fontSize: '4rem' }}>📦</span>
                )}
              </div>
              {/* End right side */}

            </div>
            {/* End card-inner */}

          </div>
          {/* End card wrapper */}

          <ConfirmDialog
            show={showDeleteConfirm}
            title={box.isVisitor ? "Remove from your feed?" : "Delete Loot Box?"}
            message={box.isVisitor
              ? `Remove "${name}" from your feed?`
              : `Are you sure you want to delete "${name}"? This action cannot be undone and all open history will be lost.`
            }
            onConfirm={handleDeleteConfirm}
            onCancel={handleDeleteCancel}
            confirmText={box.isVisitor ? "Remove" : "Delete"}
          />
        </>
      );
    };

    // ItemCreator (simplified)
    const getColorName = (hex) => {
      const names = {
        '#ef4444': 'Red',
        '#f97316': 'Orange',
        '#f59e0b': 'Amber',
        '#eab308': 'Yellow',
        '#84cc16': 'Lime',
        '#22c55e': 'Green',
        '#10b981': 'Emerald',
        '#06b6d4': 'Cyan',
        '#3b82f6': 'Blue',
        '#1e40af': 'Navy',
        '#6366f1': 'Indigo',
        '#8b5cf6': 'Violet',
        '#a855f7': 'Purple',
        '#ec4899': 'Pink',
        '#f43f5e': 'Rose',
        '#78716c': 'Stone',
        '#a8a29e': 'Warm Gray',
        '#92400e': 'Brown',
        '#b45309': 'Dark Amber',
        '#854d0e': 'Dark Gold',
        '#374151': 'Charcoal',
        '#6b7280': 'Gray',
        '#9ca3af': 'Silver',
        '#d4d4d8': 'Light Gray',
        '#ffffff': 'White',
      };
      return names[hex] || hex;
    };

    const ItemCreator = ({ items, onAddItem, editingItem, onUpdateItem, onCancelEdit, userSettings }) => {
      const [itemForm, setItemForm] = useState({ name: '', percentage: '', color: '#3b82f6', maxQuantity: '', imageUrl: '' });
      const [colorPickerOpen, setColorPickerOpen] = useState(false);
      const isMobile = useIsMobile();
      const remainingPercentage = editingItem
        ? getRemainingPercentage(items.filter(i => i.id !== editingItem.id))
        : getRemainingPercentage(items);

      // Pre-fill form when editing
      useEffect(() => {
        if (editingItem) {
          setItemForm({
            name: editingItem.name,
            percentage: editingItem.percentage.toString(),
            color: editingItem.color,
            maxQuantity: editingItem.maxQuantity ? editingItem.maxQuantity.toString() : '',
            imageUrl: editingItem.imageUrl || '',
          });
        }
      }, [editingItem]);

      const handleSubmit = (e) => {
        e.preventDefault();
        if (!itemForm.name || !itemForm.percentage) return;

        const itemData = {
          id: editingItem ? editingItem.id : Date.now().toString(),
          name: itemForm.name,
          percentage: parseFloat(itemForm.percentage),
          color: itemForm.color,
          maxQuantity: itemForm.maxQuantity ? parseInt(itemForm.maxQuantity) : null,
          imageUrl: itemForm.imageUrl || null,
        };

        if (editingItem) {
          onUpdateItem(itemData);
        } else {
          onAddItem(itemData);
        }

        setItemForm({ name: '', percentage: '', color: itemForm.color, maxQuantity: '', imageUrl: '' });
      };

      const handleCancel = () => {
        if (editingItem && onCancelEdit) {
          onCancelEdit();
        }
        setItemForm({ name: '', percentage: '', color: '#3b82f6', maxQuantity: '', imageUrl: '' });
      };

      const predefinedColors = [
        '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16',
        '#22c55e', '#10b981', '#06b6d4', '#3b82f6', '#1e40af',
        '#6366f1', '#8b5cf6', '#a855f7', '#ec4899', '#f43f5e',
        '#78716c', '#a8a29e', '#92400e', '#b45309', '#854d0e',
        '#374151', '#6b7280', '#9ca3af', '#d4d4d8', '#ffffff',
      ];

      return (
        <Card style={{ marginBottom: '2rem' }}>
          <h3 style={{ fontSize: '1.25rem', fontWeight: 600, color: '#e2e8f0', marginBottom: '1rem' }}>
            {editingItem ? 'Edit Item' : 'Add Item'}
          </h3>

          <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
            <Input
              label="Item Name"
              placeholder="e.g., Legendary Sword"
              value={itemForm.name}
              onChange={(e) => setItemForm({ ...itemForm, name: e.target.value })}
              fullWidth
              required
            />

            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', alignItems: 'end' }}>
              <Input
                type="number"
                label="Percentage"
                placeholder={`Max ${remainingPercentage.toFixed(2)}%`}
                value={itemForm.percentage}
                onChange={(e) => setItemForm({ ...itemForm, percentage: e.target.value })}
                step="0.01"
                min="0.01"
                max={remainingPercentage}
                fullWidth
                required
              />

              <Input
                type="number"
                label="Max Qty (Optional)"
                placeholder="Unlimited"
                value={itemForm.maxQuantity}
                onChange={(e) => setItemForm({ ...itemForm, maxQuantity: e.target.value })}
                min="1"
                fullWidth
              />
            </div>

            <div>
              <label style={{ display: 'block', fontSize: '0.875rem', fontWeight: 500, color: '#cbd5e1', marginBottom: '0.5rem' }}>
                Item Color
              </label>

              {/* Color picker trigger button */}
              <button
                type="button"
                onClick={() => setColorPickerOpen(!colorPickerOpen)}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.75rem',
                  width: '100%',
                  padding: '0.75rem 1rem',
                  background: 'rgba(15, 22, 36, 0.6)',
                  border: colorPickerOpen
                    ? '2px solid #3b82f6'
                    : '2px solid rgba(59, 130, 246, 0.2)',
                  borderRadius: '12px',
                  cursor: 'pointer',
                  fontFamily: 'inherit',
                  transition: 'all 0.2s ease',
                }}
              >
                <div style={{
                  width: '28px',
                  height: '28px',
                  borderRadius: '8px',
                  background: itemForm.color,
                  border: itemForm.color === '#ffffff'
                    ? '2px solid rgba(148, 163, 184, 0.5)'
                    : '2px solid rgba(255, 255, 255, 0.15)',
                  boxShadow: `0 0 8px ${itemForm.color}40`,
                  flexShrink: 0,
                }} />
                <span style={{
                  flex: 1,
                  textAlign: 'left',
                  color: '#e2e8f0',
                  fontSize: '0.9rem',
                  fontWeight: 500,
                }}>
                  {getColorName(itemForm.color)}
                </span>
                <svg
                  width="16" height="16" viewBox="0 0 16 16" fill="none"
                  style={{
                    transform: colorPickerOpen ? 'rotate(180deg)' : 'rotate(0deg)',
                    transition: 'transform 0.2s ease',
                    flexShrink: 0,
                  }}
                >
                  <path d="M4 6L8 10L12 6" stroke="#94a3b8" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                </svg>
              </button>

              {/* Inline color grid - renders in normal flow, no positioning */}
              {colorPickerOpen && (
                <div style={{
                  marginTop: '0.5rem',
                  padding: '0.75rem',
                  background: 'rgba(15, 22, 36, 0.95)',
                  border: '2px solid rgba(59, 130, 246, 0.3)',
                  borderRadius: '12px',
                }}>
                  <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(5, 1fr)',
                    gap: '0.4rem',
                  }}>
                    {predefinedColors.map(color => (
                      <button
                        key={color}
                        type="button"
                        style={{
                          width: '100%',
                          aspectRatio: '1',
                          background: color,
                          borderRadius: '6px',
                          border: itemForm.color === color
                            ? '2px solid #ffffff'
                            : color === '#ffffff'
                              ? '2px solid rgba(148, 163, 184, 0.5)'
                              : '2px solid rgba(59, 130, 246, 0.15)',
                          cursor: 'pointer',
                          transform: itemForm.color === color ? 'scale(1.1)' : 'scale(1)',
                          boxShadow: itemForm.color === color ? `0 0 12px ${color}80` : 'none',
                          transition: 'all 0.15s ease',
                        }}
                        onClick={() => {
                          setItemForm({ ...itemForm, color });
                          setColorPickerOpen(false);
                        }}
                      />
                    ))}
                  </div>
                </div>
              )}
            </div>

            <Button type="submit" variant="primary" fullWidth disabled={remainingPercentage <= 0 || !itemForm.name || !itemForm.percentage}>
              {editingItem ? 'Update Item' : 'Add Item'}
            </Button>
            
            {editingItem && (
              <Button type="button" variant="ghost" fullWidth onClick={handleCancel} style={{ marginTop: '0.5rem' }}>
                Cancel Edit
              </Button>
            )}
          </form>
        </Card>
      );
    };

    // ItemList (simplified)
    const ItemList = ({ items, onRemoveItem, onEditItem }) => {
      if (items.length === 0) {
        return null;
      }

      return (
        <div>
          <h3 style={{ fontSize: '1.125rem', fontWeight: 600, color: '#e2e8f0', marginBottom: '0.75rem' }}>
            Items ({items.length})
          </h3>

          <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
            {items.map(item => (
              <div
                key={item.id}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '1rem',
                  padding: '0.75rem 1rem',
                  background: 'rgba(15, 22, 36, 0.6)',
                  border: `2px solid ${item.color}40`,
                  borderLeft: `4px solid ${item.color}`,
                  borderRadius: '8px',
                }}
              >
                {item.imageUrl ? (
                  <img
                    src={item.imageUrl}
                    alt={item.name}
                    style={{
                      width: '40px',
                      height: '40px',
                      objectFit: 'contain',
                      borderRadius: '6px',
                      border: `1px solid ${item.color}40`,
                    }}
                  />
                ) : (
                  <span style={{
                    width: '12px',
                    height: '12px',
                    borderRadius: '50%',
                    background: item.color,
                    boxShadow: `0 0 8px ${item.color}80`,
                  }} />
                )}

                <div style={{ flex: 1 }}>
                  <div style={{ fontSize: '1rem', fontWeight: 600, color: '#e2e8f0' }}>
                    {item.name}
                  </div>
                  {item.maxQuantity && (
                    <div style={{ fontSize: '0.875rem', color: '#94a3b8' }}>
                      Max: {item.maxQuantity}
                    </div>
                  )}
                </div>

                <span style={{ fontSize: '1.25rem', fontWeight: 700, color: '#60a5fa' }}>
                  {item.percentage}%
                </span>

                <button
                  style={{
                    width: '32px',
                    height: '32px',
                    background: 'transparent',
                    border: '1px solid rgba(59, 130, 246, 0.3)',
                    borderRadius: '6px',
                    color: '#60a5fa',
                    cursor: 'pointer',
                    fontSize: '1rem',
                    fontWeight: 600,
                  }}
                  onClick={() => onEditItem(item)}
                  title="Edit item"
                >
                  ✎
                </button>

                <button
                  style={{
                    width: '32px',
                    height: '32px',
                    background: 'transparent',
                    border: '1px solid rgba(239, 68, 68, 0.3)',
                    borderRadius: '6px',
                    color: '#ef4444',
                    cursor: 'pointer',
                    fontSize: '1.125rem',
                  }}
                  onClick={() => onRemoveItem(item.id)}
                  title="Remove item"
                >
                  ×
                </button>
              </div>
            ))}
          </div>
        </div>
      );
    };

    // ImagePicker Component
    const ImagePicker = ({ selectedImageId, onSelectImage, userSettings, success, error, info }) => {
      const [activeTab, setActiveTab] = useState('defaults');
      const [boxCatalog, setBoxCatalog] = useState(null);
      const [loading, setLoading] = useState(true);
      const [showPurchaseModal, setShowPurchaseModal] = useState(null);
      const [uploading, setUploading] = useState(false);
      const isMobile = useIsMobile();
      const selectedRef = useRef(null);

      useEffect(() => {
        loadBoxCatalog();
      }, []);

      const loadBoxCatalog = async () => {
        setLoading(true);
        try {
          const catalog = await getAllAvailableBoxImages(userSettings);
          setBoxCatalog(catalog);
        } catch (error) {
          console.error('Error loading box catalog:', error);
        } finally {
          setLoading(false);
        }
      };

      const handleImageClick = (image) => {
        const canUse = canUserUseBox(image);

        if (canUse) {
          // Store the full URL for Firebase boxes, ID for hardcoded
          const imageRef = image.imageUrl && image.imageUrl.startsWith('http')
            ? image.imageUrl
            : image.id;
          onSelectImage(imageRef);
          // Auto-scroll selected image into view on mobile
          if (isMobile) {
            setTimeout(() => {
              selectedRef.current?.scrollIntoView({
                behavior: 'smooth',
                block: 'nearest',
                inline: 'center',
              });
            }, 50);
          }
        } else {
          // Show purchase modal for locked boxes (works for free and premium users)
          setShowPurchaseModal(image);
        }
      };

      // Check if user can use this specific box
      const canUserUseBox = (image) => {
        // Default boxes (hardcoded OR from Firebase) - always free
        if (image.source === BOX_SOURCES.DEFAULT || image.source === 'default') return true;

        // Premium boxes - free for premium users only
        if (image.source === BOX_SOURCES.PREMIUM || image.source === 'premium') {
          return userSettings.tier === 'paid';
        }

        // User's own uploads
        if (image.source === BOX_SOURCES.USER_UPLOADED &&
            userSettings.uploadedBoxes?.includes(image.id)) return true;

        // Purchased boxes
        if (userSettings.ownedBoxes?.includes(image.id)) return true;

        return false;
      };

      const handlePurchase = async (box) => {
        if (!firebaseEnabled) {
          error('Purchase feature requires Firebase configuration');
          setShowPurchaseModal(null);
          return;
        }

        if (!userSettings.uid) {
          error('Please sign in to purchase boxes');
          setShowPurchaseModal(null);
          return;
        }

        try {
          // TODO: Integrate with actual payment provider (Stripe, etc.)
          // For now, this is a placeholder that would trigger payment flow
          await purchaseBox(box.id, userSettings.uid);

          // Update local settings with new owned box
          const updatedSettings = {
            ...userSettings,
            ownedBoxes: [...(userSettings.ownedBoxes || []), box.id]
          };
          localStorage.setItem(STORAGE_KEYS.USER_SETTINGS, JSON.stringify(updatedSettings));

          success(`Successfully purchased ${box.name}!`);
          await loadBoxCatalog(); // Refresh catalog
          setShowPurchaseModal(null);
        } catch (err) {
          error(`Purchase failed: ${err.message}`);
        }
      };

      const handleFileUpload = async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;

        if (userSettings.tier !== 'paid') {
          error('Custom box uploads are a premium feature!');
          return;
        }

        if (!firebaseEnabled) {
          error('Upload feature requires Firebase configuration');
          return;
        }

        if (!userSettings.uid) {
          error('Please sign in to upload custom boxes');
          return;
        }

        setUploading(true);
        try {
          const uploadedBox = await uploadUserBox(file, { name: file.name }, userSettings.uid);
          success(`Successfully uploaded ${uploadedBox.name}!`);
          await loadBoxCatalog(); // Refresh catalog
        } catch (err) {
          error(`Upload failed: ${err.message}`);
        } finally {
          setUploading(false);
        }
      };

      const getActiveBoxes = () => {
        if (!boxCatalog) return [];

        switch (activeTab) {
          case 'defaults':
            return boxCatalog.defaults;
          case 'seasonal':
            return boxCatalog.seasonal;
          case 'store':
            return boxCatalog.store;
          case 'premium':
            return boxCatalog.premium;
          case 'uploads':
            return boxCatalog.userUploaded;
          default:
            return [];
        }
      };

      const tabs = [
        { id: 'defaults', label: 'Defaults', count: boxCatalog?.defaults.length || 0 },
        { id: 'premium', label: 'Premium', count: boxCatalog?.premium.length || 0, premium: true },
        { id: 'seasonal', label: 'Seasonal', count: boxCatalog?.seasonal.length || 0 },
        { id: 'store', label: 'Store', count: boxCatalog?.store.length || 0 },
        { id: 'uploads', label: 'My Uploads', count: boxCatalog?.userUploaded.length || 0, premium: true },
      ];

      const activeBoxes = getActiveBoxes();

      return (
        <div style={{ marginBottom: '1.5rem' }}>
          <label style={{
            display: 'block',
            fontSize: '0.875rem',
            fontWeight: 500,
            color: '#cbd5e1',
            marginBottom: '0.75rem',
          }}>
            Box Image
          </label>

          {/* Tabs */}
          <div style={{
            display: 'flex',
            gap: '0.5rem',
            marginBottom: '1rem',
            overflowX: 'auto',
          }}>
            {tabs.map(tab => {
              const isActive = activeTab === tab.id;
              const isLocked = tab.premium && userSettings.tier !== 'paid';

              return (
                <button
                  key={tab.id}
                  style={{
                    flex: '0 0 auto',
                    padding: '0.4rem 0.75rem',
                    fontSize: '0.8rem',
                    fontWeight: 600,
                    color: isActive ? '#ffffff' : '#94a3b8',
                    background: isActive
                      ? 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)'
                      : 'rgba(15, 22, 36, 0.6)',
                    border: `1px solid ${isActive ? '#3b82f6' : 'rgba(59, 130, 246, 0.2)'}`,
                    borderRadius: '8px',
                    cursor: isLocked ? 'not-allowed' : 'pointer',
                    opacity: isLocked ? 0.5 : 1,
                    fontFamily: 'inherit',
                    transition: 'all 0.2s ease',
                  }}
                  onClick={() => !isLocked && setActiveTab(tab.id)}
                  disabled={isLocked}
                >
                  {tab.label} {tab.count > 0 && `(${tab.count})`}
                  {isLocked && ' 🔒'}
                </button>
              );
            })}
          </div>

          {/* Upload Button for Premium Users */}
          {activeTab === 'uploads' && userSettings.tier === 'paid' && (
            <div style={{ marginBottom: '1rem' }}>
              <label style={{
                display: 'inline-block',
                padding: '0.75rem 1.5rem',
                fontSize: '0.875rem',
                fontWeight: 600,
                color: '#ffffff',
                background: uploading
                  ? 'rgba(59, 130, 246, 0.5)'
                  : 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
                borderRadius: '8px',
                cursor: uploading ? 'not-allowed' : 'pointer',
                transition: 'all 0.2s ease',
              }}>
                {uploading ? 'Uploading...' : '+ Upload Custom Box'}
                <input
                  type="file"
                  accept="image/*"
                  onChange={handleFileUpload}
                  disabled={uploading}
                  style={{ display: 'none' }}
                />
              </label>
            </div>
          )}

          {/* Loading State */}
          {loading && (
            <div style={{
              textAlign: 'center',
              padding: '2rem',
              color: '#64748b',
            }}>
              Loading boxes...
            </div>
          )}

          {/* Box Grid */}
          {!loading && (
            <div style={{ position: 'relative', overflow: 'visible' }}>
            <div
              className={isMobile ? 'mobile-image-scroll' : undefined}
              style={isMobile ? {
                display: 'flex',
                flexDirection: 'row',
                overflowX: 'auto',
                overflowY: 'hidden',
                gap: '0.5rem',
                padding: '0.75rem 1.25rem 0.75rem 0',
                scrollPadding: '0 1.25rem 0 0',
                WebkitOverflowScrolling: 'touch',
                scrollSnapType: 'x mandatory',
              } : {
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(90px, 1fr))',
                gap: '0.75rem',
                padding: '10px 10px 10px 0',
              }}
            >
              {activeBoxes.length === 0 && (
                <div style={{
                  ...(isMobile ? {} : { gridColumn: '1 / -1' }),
                  textAlign: 'center',
                  padding: '2rem',
                  color: '#64748b',
                  width: '100%',
                }}>
                  {activeTab === 'uploads'
                    ? 'No uploaded boxes yet. Upload your first custom box!'
                    : 'No boxes available in this category'}
                </div>
              )}

              {activeBoxes.map(image => {
                const canUse = canUserUseBox(image);
                const isSelected = selectedImageId === image.id || selectedImageId === image.imageUrl;
                const isSeasonal = image.source === BOX_SOURCES.SEASONAL;
                const isStore = image.source === BOX_SOURCES.STORE;
                const isUserUpload = image.source === BOX_SOURCES.USER_UPLOADED;

                return (
                  <div
                    key={image.id}
                    ref={isSelected ? selectedRef : null}
                    style={{
                      position: 'relative',
                      cursor: 'pointer',
                      padding: '0.5rem',
                      background: 'rgba(15, 22, 36, 0.6)',
                      border: `3px solid ${isSelected ? '#3b82f6' : 'rgba(59, 130, 246, 0.2)'}`,
                      borderRadius: '12px',
                      transition: 'all 0.2s ease',
                      boxShadow: isSelected ? 'inset 0 0 15px rgba(59, 130, 246, 0.3)' : 'none',
                      ...(isMobile ? {
                        flexShrink: 0,
                        width: '72px',
                        scrollSnapAlign: 'start',
                      } : {}),
                    }}
                    onClick={() => handleImageClick(image)}
                  >
                    {/* Image preview */}
                    <div style={{
                      width: '100%',
                      height: isMobile ? '60px' : '65px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      background: 'linear-gradient(135deg, rgba(30, 64, 175, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%)',
                      borderRadius: '8px',
                      marginBottom: '0.5rem',
                      opacity: canUse ? 1 : 0.5,
                      overflow: 'hidden',
                      position: 'relative',
                    }}>
                      <img
                        src={getBoxImageUrl(image.id, boxCatalog)}
                        alt={image.name}
                        style={{
                          width: '100%',
                          height: '100%',
                          objectFit: 'contain',
                        }}
                      />
                      {!canUse && (
                        <div style={{
                          position: 'absolute',
                          top: '50%',
                          left: '50%',
                          transform: 'translate(-50%, -50%)',
                          fontSize: '2rem',
                        }}>
                          🔒
                        </div>
                      )}
                    </div>

                    {/* Image name */}
                    <div
                      title={image.name}
                      style={{
                        fontSize: '0.65rem',
                        fontWeight: 600,
                        color: '#cbd5e1',
                        textAlign: 'center',
                        marginBottom: '0.25rem',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap',
                      }}
                    >
                      {image.name}
                    </div>

                    {/* Badges */}
                    {isSeasonal && image.seasonalInfo && (
                      <div style={{
                        position: 'absolute',
                        top: '0.5rem',
                        right: '0.5rem',
                        padding: '0.25rem 0.5rem',
                        background: 'linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%)',
                        borderRadius: '6px',
                        fontSize: '0.625rem',
                        fontWeight: 700,
                        color: '#ffffff',
                        textTransform: 'uppercase',
                      }}>
                        {image.seasonalInfo.label || 'Seasonal'}
                      </div>
                    )}

                    {isStore && !canUse && image.price !== null && (
                      <div style={{
                        position: 'absolute',
                        top: '0.5rem',
                        right: '0.5rem',
                        padding: '0.25rem 0.5rem',
                        background: 'linear-gradient(135deg, #f59e0b 0%, #3b82f6 100%)',
                        borderRadius: '6px',
                        fontSize: '0.625rem',
                        fontWeight: 700,
                        color: '#ffffff',
                        textTransform: 'uppercase',
                      }}>
                        ${image.price}
                      </div>
                    )}

                    {isUserUpload && (
                      <div style={{
                        position: 'absolute',
                        top: '0.5rem',
                        right: '0.5rem',
                        padding: '0.25rem 0.5rem',
                        background: 'rgba(16, 185, 129, 0.9)',
                        borderRadius: '6px',
                        fontSize: '0.625rem',
                        fontWeight: 700,
                        color: '#ffffff',
                        textTransform: 'uppercase',
                      }}>
                        Your Upload
                      </div>
                    )}

                    {canUse && !isUserUpload && image.source !== BOX_SOURCES.DEFAULT && (
                      <div style={{
                        position: 'absolute',
                        top: '0.5rem',
                        left: '0.5rem',
                        padding: '0.25rem 0.5rem',
                        background: 'rgba(16, 185, 129, 0.9)',
                        borderRadius: '6px',
                        fontSize: '0.625rem',
                        fontWeight: 700,
                        color: '#ffffff',
                        textTransform: 'uppercase',
                      }}>
                        Owned
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
            </div>
          )}

          {/* Purchase Modal */}
          {showPurchaseModal && (
            <ConfirmDialog
              show={true}
              title={`Purchase ${showPurchaseModal.name}?`}
              message={`Unlock this ${showPurchaseModal.source === BOX_SOURCES.SEASONAL ? 'seasonal ' : ''}box skin${showPurchaseModal.price !== null ? ` for $${showPurchaseModal.price}` : ''}. You'll own it forever and can use it on unlimited loot boxes!`}
              onConfirm={() => handlePurchase(showPurchaseModal)}
              onCancel={() => setShowPurchaseModal(null)}
              confirmText={`Purchase${showPurchaseModal.price !== null ? ` $${showPurchaseModal.price}` : ''}`}
              cancelText="Cancel"
            />
          )}
        </div>
      );
    };

    // BoxCreator
    const BoxCreator = ({ onComplete, onCancel, editingBox = null, success, error, info }) => {
      const [boxName, setBoxName] = useState(editingBox ? editingBox.name : '');
      const [items, setItems] = useState(editingBox ? editingBox.items : []);
      const [maxPulls, setMaxPulls] = useState(editingBox && editingBox.maxPulls ? editingBox.maxPulls.toString() : '');
      const [maxPullsPerUser, setMaxPullsPerUser] = useState(editingBox && editingBox.maxPullsPerUser ? editingBox.maxPullsPerUser.toString() : '');
      const [boxType, setBoxType] = useState(editingBox ? editingBox.type : 'local');
      const [editingItem, setEditingItem] = useState(null);
      const [hideContents, setHideContents] = useState(editingBox ? editingBox.hideContents || false : false);
      const [hideOdds, setHideOdds] = useState(editingBox ? editingBox.hideOdds || false : false);
      const [allowParticipantSharing, setAllowParticipantSharing] = useState(
        editingBox ? editingBox.allowParticipantSharing || false : false
      );
      const [expiresAt, setExpiresAt] = useState(() => {
        if (editingBox && editingBox.expiresAt) {
          // Convert timestamp to datetime-local format for the input
          const d = new Date(editingBox.expiresAt);
          return d.getFullYear() + '-' +
            String(d.getMonth() + 1).padStart(2, '0') + '-' +
            String(d.getDate()).padStart(2, '0') + 'T' +
            String(d.getHours()).padStart(2, '0') + ':' +
            String(d.getMinutes()).padStart(2, '0');
        }
        return '';
      });
      const [boxImageId, setBoxImageId] = useState(editingBox ? editingBox.boxImageId || 'chest' : 'chest');
      const [showAdvanced, setShowAdvanced] = useState(
        editingBox ? !!(editingBox.hideContents || editingBox.hideOdds || editingBox.expiresAt) : false
      );
      const [expirationEnabled, setExpirationEnabled] = useState(
        editingBox ? !!editingBox.expiresAt : false
      );

      const userSettings = getUserSettings();
      const isPaidUser = userSettings.tier === 'paid';
      const canCreateLocal = editingBox || canCreateLocalBox(); // Allow if editing existing box

      const handleAddItem = (item) => {
        setItems([...items, item]);
      };

      const handleUpdateItem = (updatedItem) => {
        setItems(items.map(item => item.id === updatedItem.id ? updatedItem : item));
        setEditingItem(null);
      };

      const handleEditItem = (item) => {
        setEditingItem(item);
      };

      const handleCancelEdit = () => {
        setEditingItem(null);
      };

      const handleCreate = async () => {
        if (!boxName.trim()) {
          error('Please enter a box name');
          return;
        }

        if (items.length === 0) {
          error('Please add at least one item');
          return;
        }

        const validation = validatePercentages(items);
        if (!validation.valid) {
          error(`Percentages must add up to 100%. ${validation.message}`);
          return;
        }

        if (boxType === 'local' && !editingBox && !canCreateLocal) {
          error('Free users can only create 5 local boxes!');
          return;
        }

        const boxData = {
          id: editingBox ? editingBox.id : Date.now().toString(),
          name: boxName.trim(),
          items,
          maxPulls: maxPulls ? parseInt(maxPulls) : null,
          maxPullsPerUser: maxPullsPerUser ? parseInt(maxPullsPerUser) : null,
          type: boxType,
          shareCode: editingBox ? editingBox.shareCode : generateShareCode(),
          pullHistory: editingBox ? editingBox.pullHistory : [],
          createdAt: editingBox ? editingBox.createdAt : Date.now(),
          boxImageId: boxImageId,
          hideContents: hideContents,
          hideOdds: hideOdds,
          expiresAt: expiresAt ? new Date(expiresAt).getTime() : null,
          allowParticipantSharing: boxType === 'shared' ? allowParticipantSharing : false,
        };

        // If shared box, save to Firestore
        if (boxType === 'shared' || (editingBox && editingBox.type === 'shared')) {
          try {
            await saveSharedBox(boxData);

            // Save lightweight reference locally for creator
            const localRef = {
              id: boxData.id,
              name: boxData.name,
              type: 'shared',
              shareCode: boxData.shareCode,
              isSharedRef: true,
              items: boxData.items,
              maxPulls: boxData.maxPulls,
              maxPullsPerUser: boxData.maxPullsPerUser,
              pullHistory: [],
              createdAt: boxData.createdAt,
              boxImageId: boxData.boxImageId,
              hideContents: boxData.hideContents,
              hideOdds: boxData.hideOdds,
              expiresAt: boxData.expiresAt,
              allowParticipantSharing: boxData.allowParticipantSharing,
            };
            saveBox(localRef);
          } catch (err) {
            error('Failed to save shared box: ' + err.message);
            return;
          }
        } else {
          // Local box - save only to localStorage
          saveBox(boxData);
        }

        onComplete && onComplete(boxData);
      };

      const validation = validatePercentages(items);

      return (
        <div style={{ maxWidth: '800px', margin: '0 auto' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '2rem' }}>
            <button onClick={onCancel} style={{
              width: '36px', height: '36px',
              display: 'flex', alignItems: 'center', justifyContent: 'center',
              background: 'rgba(255, 51, 51, 0.4)',
              border: '1px solid rgba(255, 51, 51, 0.6)',
              borderRadius: '50%',
              cursor: 'pointer',
              color: '#e2e8f0',
              padding: 0, flexShrink: 0,
              transition: 'all 0.2s ease',
            }}
            onMouseEnter={e => { e.currentTarget.style.background = 'rgba(255, 51, 51, 0.55)'; e.currentTarget.style.borderColor = 'rgba(255, 51, 51, 0.75)'; }}
            onMouseLeave={e => { e.currentTarget.style.background = 'rgba(255, 51, 51, 0.4)'; e.currentTarget.style.borderColor = 'rgba(255, 51, 51, 0.6)'; }}
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="15 18 9 12 15 6" />
              </svg>
            </button>
            <h2 style={{ fontSize: '2rem', fontWeight: 700, color: '#e2e8f0', margin: 0 }}>
              {editingBox ? 'Edit Loot Box' : 'Create Loot Box'}
            </h2>
          </div>

          <div style={{ marginBottom: '2rem' }}>
            <Card>
              <Input
                label="Box Name"
                placeholder="e.g., Epic Mystery Box"
                value={boxName}
                onChange={(e) => setBoxName(e.target.value)}
                fullWidth
              />

              <div style={{ marginTop: '0.75rem' }}>
                <ImagePicker
                  selectedImageId={boxImageId}
                  onSelectImage={setBoxImageId}
                  userSettings={userSettings}
                  success={success}
                  error={error}
                  info={info}
                />
              </div>

              <div style={{ marginTop: '0.75rem' }}>
                <label style={{ display: 'block', fontSize: '0.875rem', fontWeight: 500, color: '#cbd5e1', marginBottom: '0.5rem' }}>
                  Box Type
                </label>
                <div style={{ display: 'flex', gap: '1rem' }}>
                  <button
                    style={{
                      padding: '0.75rem 1.5rem',
                      background: boxType === 'local' ? 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)' : 'rgba(15, 22, 36, 0.6)',
                      border: `2px solid ${boxType === 'local' ? '#3b82f6' : 'rgba(59, 130, 246, 0.2)'}`,
                      borderRadius: '12px',
                      color: boxType === 'local' ? '#ffffff' : '#94a3b8',
                      fontWeight: 600,
                      cursor: 'pointer',
                      fontFamily: 'inherit',
                    }}
                    onClick={() => setBoxType('local')}
                  >
                    Local
                    {!canCreateLocal && <div style={{ fontSize: '0.75rem', marginTop: '0.25rem', opacity: 0.8 }}>(Limit reached)</div>}
                  </button>
                  <button
                    style={{
                      padding: '0.75rem 1.5rem',
                      background: boxType === 'shared' ? 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)' : 'rgba(15, 22, 36, 0.6)',
                      border: `2px solid ${boxType === 'shared' ? '#3b82f6' : 'rgba(59, 130, 246, 0.2)'}`,
                      borderRadius: '12px',
                      color: boxType === 'shared' ? '#ffffff' : '#94a3b8',
                      fontWeight: 600,
                      cursor: 'pointer',
                      fontFamily: 'inherit',
                      opacity: isPaidUser ? 1 : 0.6,
                    }}
                    onClick={() => setBoxType('shared')}
                    disabled={!isPaidUser}
                  >
                    Shared
                    {!isPaidUser && <div style={{ fontSize: '0.75rem', marginTop: '0.25rem', opacity: 0.8 }}>(Premium only)</div>}
                  </button>
                </div>
              </div>

              <div style={{ marginTop: '0.75rem', display: 'grid', gridTemplateColumns: boxType === 'shared' ? '1fr 1fr' : '1fr', gap: '1rem', maxWidth: boxType === 'shared' ? '500px' : '250px' }}>
                <Input
                  type="number"
                  label="Max Opens Total (Optional)"
                  placeholder="Unlimited"
                  value={maxPulls}
                  onChange={(e) => setMaxPulls(e.target.value)}
                  min="1"
                  fullWidth
                />
                {boxType === 'shared' && (
                  <Input
                    type="number"
                    label="Max Opens Per Person (Optional)"
                    placeholder="Unlimited"
                    value={maxPullsPerUser}
                    onChange={(e) => setMaxPullsPerUser(e.target.value)}
                    min="1"
                    fullWidth
                  />
                )}
              </div>

              {/* Advanced Settings */}
              <div style={{ marginTop: '0.75rem' }}>
                <div
                  onClick={() => setShowAdvanced(!showAdvanced)}
                  style={{
                    display: 'inline-flex',
                    alignItems: 'center',
                    gap: '0.5rem',
                    padding: '0.55rem 0.85rem',
                    background: 'rgba(15, 22, 36, 0.6)',
                    border: '1px solid rgba(59, 130, 246, 0.2)',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    userSelect: 'none',
                  }}
                >
                  <span style={{ color: '#cbd5e1', fontWeight: 600, fontSize: '0.875rem' }}>
                    Advanced Settings
                  </span>
                  <span style={{
                    color: '#94a3b8',
                    fontSize: '0.75rem',
                    transition: 'transform 0.2s ease',
                    transform: showAdvanced ? 'rotate(180deg)' : 'rotate(0deg)',
                    display: 'inline-block',
                  }}>
                    ▼
                  </span>
                </div>

                {showAdvanced && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem', marginTop: '0.5rem' }}>
                    {/* Hide Contents toggle */}
                    <div style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      padding: '0.6rem 0.75rem',
                      background: 'rgba(30, 64, 175, 0.15)',
                      border: '1px solid rgba(59, 130, 246, 0.2)',
                      borderRadius: '8px',
                    }}>
                      <div>
                        <div style={{ color: '#e2e8f0', fontWeight: 600, fontSize: '0.9rem' }}>
                          Hide Contents
                        </div>
                        <div style={{ color: '#94a3b8', fontSize: '0.75rem', marginTop: '0.15rem' }}>
                          Items hidden until opened
                        </div>
                      </div>
                      <label style={{
                        position: 'relative',
                        display: 'inline-block',
                        width: '44px',
                        height: '24px',
                        cursor: 'pointer',
                        flexShrink: 0,
                      }}>
                        <input
                          type="checkbox"
                          checked={hideContents}
                          onChange={(e) => setHideContents(e.target.checked)}
                          style={{ opacity: 0, width: 0, height: 0 }}
                        />
                        <span style={{
                          position: 'absolute',
                          top: 0, left: 0, right: 0, bottom: 0,
                          background: hideContents
                            ? 'linear-gradient(135deg, #4169e1, #1e40af)'
                            : 'rgba(100, 116, 139, 0.4)',
                          borderRadius: '12px',
                          transition: 'all 0.3s ease',
                        }}>
                          <span style={{
                            position: 'absolute',
                            height: '18px',
                            width: '18px',
                            left: hideContents ? '22px' : '3px',
                            bottom: '3px',
                            background: '#fff',
                            borderRadius: '50%',
                            transition: 'all 0.3s ease',
                          }} />
                        </span>
                      </label>
                    </div>

                    {/* Hide Odds toggle */}
                    <div style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      padding: '0.6rem 0.75rem',
                      background: 'rgba(30, 64, 175, 0.15)',
                      border: '1px solid rgba(59, 130, 246, 0.2)',
                      borderRadius: '8px',
                    }}>
                      <div>
                        <div style={{ color: '#e2e8f0', fontWeight: 600, fontSize: '0.9rem' }}>
                          Hide Odds
                        </div>
                        <div style={{ color: '#94a3b8', fontSize: '0.75rem', marginTop: '0.15rem' }}>
                          Percentages stay secret
                        </div>
                      </div>
                      <label style={{
                        position: 'relative',
                        display: 'inline-block',
                        width: '44px',
                        height: '24px',
                        cursor: 'pointer',
                        flexShrink: 0,
                      }}>
                        <input
                          type="checkbox"
                          checked={hideOdds}
                          onChange={(e) => setHideOdds(e.target.checked)}
                          style={{ opacity: 0, width: 0, height: 0 }}
                        />
                        <span style={{
                          position: 'absolute',
                          top: 0, left: 0, right: 0, bottom: 0,
                          background: hideOdds
                            ? 'linear-gradient(135deg, #4169e1, #1e40af)'
                            : 'rgba(100, 116, 139, 0.4)',
                          borderRadius: '12px',
                          transition: 'all 0.3s ease',
                        }}>
                          <span style={{
                            position: 'absolute',
                            height: '18px',
                            width: '18px',
                            left: hideOdds ? '22px' : '3px',
                            bottom: '3px',
                            background: '#fff',
                            borderRadius: '50%',
                            transition: 'all 0.3s ease',
                          }} />
                        </span>
                      </label>
                    </div>

                    {/* Expiration Date toggle */}
                    <div style={{
                      padding: '0.6rem 0.75rem',
                      background: 'rgba(30, 64, 175, 0.15)',
                      border: '1px solid rgba(59, 130, 246, 0.2)',
                      borderRadius: '8px',
                    }}>
                      <div style={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                      }}>
                        <div>
                          <div style={{ color: '#e2e8f0', fontWeight: 600, fontSize: '0.9rem' }}>
                            Expiration Date
                          </div>
                          <div style={{ color: '#94a3b8', fontSize: '0.75rem', marginTop: '0.15rem' }}>
                            Box expires after a set date
                          </div>
                        </div>
                        <label style={{
                          position: 'relative',
                          display: 'inline-block',
                          width: '44px',
                          height: '24px',
                          cursor: 'pointer',
                          flexShrink: 0,
                        }}>
                          <input
                            type="checkbox"
                            checked={expirationEnabled}
                            onChange={(e) => {
                              setExpirationEnabled(e.target.checked);
                              if (!e.target.checked) setExpiresAt('');
                            }}
                            style={{ opacity: 0, width: 0, height: 0 }}
                          />
                          <span style={{
                            position: 'absolute',
                            top: 0, left: 0, right: 0, bottom: 0,
                            background: expirationEnabled
                              ? 'linear-gradient(135deg, #4169e1, #1e40af)'
                              : 'rgba(100, 116, 139, 0.4)',
                            borderRadius: '12px',
                            transition: 'all 0.3s ease',
                          }}>
                            <span style={{
                              position: 'absolute',
                              height: '18px',
                              width: '18px',
                              left: expirationEnabled ? '22px' : '3px',
                              bottom: '3px',
                              background: '#fff',
                              borderRadius: '50%',
                              transition: 'all 0.3s ease',
                            }} />
                          </span>
                        </label>
                      </div>
                      {expirationEnabled && (
                        <div style={{ marginTop: '0.5rem' }}>
                          <input
                            type="datetime-local"
                            value={expiresAt}
                            onChange={(e) => setExpiresAt(e.target.value)}
                            style={{
                              width: '100%',
                              padding: '0.5rem 0.75rem',
                              background: 'rgba(15, 22, 36, 0.6)',
                              border: '1px solid rgba(59, 130, 246, 0.3)',
                              borderRadius: '8px',
                              color: '#e2e8f0',
                              fontSize: '0.875rem',
                              fontFamily: 'inherit',
                              outline: 'none',
                            }}
                          />
                          {expiresAt && (
                            <div style={{ fontSize: '0.75rem', color: '#94a3b8', marginTop: '0.25rem' }}>
                              Expires: {new Date(expiresAt).toLocaleString()}
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>

              {/* Allow Participants to Share - outside Advanced Settings */}
              {boxType === 'shared' && (
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  padding: '0.6rem 0.75rem',
                  background: 'rgba(30, 64, 175, 0.15)',
                  border: '1px solid rgba(59, 130, 246, 0.2)',
                  borderRadius: '8px',
                  marginTop: '0.5rem',
                }}>
                  <div>
                    <div style={{ color: '#e2e8f0', fontWeight: 600, fontSize: '0.9rem' }}>
                      Allow Participants to Share
                    </div>
                    <div style={{ color: '#94a3b8', fontSize: '0.75rem', marginTop: '0.15rem' }}>
                      Let people who join this box share the link with others
                    </div>
                  </div>
                  <label style={{
                    position: 'relative',
                    display: 'inline-block',
                    width: '44px',
                    height: '24px',
                    cursor: 'pointer',
                    flexShrink: 0,
                  }}>
                    <input
                      type="checkbox"
                      checked={allowParticipantSharing}
                      onChange={(e) => setAllowParticipantSharing(e.target.checked)}
                      style={{ opacity: 0, width: 0, height: 0 }}
                    />
                    <span style={{
                      position: 'absolute',
                      top: 0, left: 0, right: 0, bottom: 0,
                      background: allowParticipantSharing
                        ? 'linear-gradient(135deg, #4169e1, #1e40af)'
                        : 'rgba(100, 116, 139, 0.4)',
                      borderRadius: '12px',
                      transition: 'all 0.3s ease',
                    }}>
                      <span style={{
                        position: 'absolute',
                        height: '18px',
                        width: '18px',
                        left: allowParticipantSharing ? '22px' : '3px',
                        bottom: '3px',
                        background: '#fff',
                        borderRadius: '50%',
                        transition: 'all 0.3s ease',
                      }} />
                    </span>
                  </label>
                </div>
              )}
            </Card>
          </div>

          <ItemCreator
            items={items}
            onAddItem={handleAddItem}
            editingItem={editingItem}
            onUpdateItem={handleUpdateItem}
            onCancelEdit={handleCancelEdit}
            userSettings={userSettings}
          />
          {items.length > 0 && (
            <div style={{ marginBottom: '1.5rem' }}>
              <ItemList
                items={items}
                onRemoveItem={(itemId) => setItems(items.filter(i => i.id !== itemId))}
                onEditItem={handleEditItem}
              />
            </div>
          )}

          {items.length > 0 && (
            <div style={{
              padding: '1rem',
              background: validation.valid ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)',
              border: `2px solid ${validation.valid ? '#10b981' : '#ef4444'}`,
              borderRadius: '12px',
              textAlign: 'center',
              marginBottom: '2rem',
            }}>
              <div style={{ fontSize: '0.875rem', color: validation.valid ? '#6ee7b7' : '#fca5a5', fontWeight: 600 }}>
                {validation.message} ({validation.total}%)
              </div>
            </div>
          )}

          <div style={{ display: 'flex', gap: '1rem' }}>
            <Button variant="secondary" onClick={onCancel} fullWidth>Cancel</Button>
            <Button variant="primary" onClick={handleCreate} disabled={!validation.valid || !boxName.trim()} fullWidth>
              {editingBox ? 'Save Changes' : 'Create Box'}
            </Button>
          </div>
        </div>
      );
    };

    // BoxOpener Component
    const isLightColor = (hex) => {
      if (!hex) return false;
      const c = hex.replace('#', '');
      const r = parseInt(c.substr(0, 2), 16);
      const g = parseInt(c.substr(2, 2), 16);
      const b = parseInt(c.substr(4, 2), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.7;
    };

    const BoxOpener = ({ box, onBack, onBoxUpdate, success, error, info }) => {
      const [pullHistory, setPullHistory] = useState(box.pullHistory || []);
      const [currentPull, setCurrentPull] = useState(null);
      const [showResult, setShowResult] = useState(false);
      const [openingPhase, setOpeningPhase] = useState('idle');
      const particleContainerRef = React.useRef(null);
      const [userName, setUserName] = useState(() => {
        if (box.type === 'shared' && box.shareCode) {
          // Check for a name saved specifically for this box
          const boxName = getBoxUserName(box.shareCode);
          if (boxName) return boxName;
          // Check for a last used name from another box
          const lastName = getLastUsedName();
          if (lastName) return lastName;
          // Check for a real display name (not the default 'Guest')
          const settings = getUserSettings();
          if (settings.displayName && settings.displayName !== 'Guest') {
            return settings.displayName;
          }
          // No name found -- will trigger prompt
          return '';
        }
        // Solo boxes use global display name
        const settings = getUserSettings();
        return settings.displayName && settings.displayName !== 'Guest'
          ? settings.displayName : 'You';
      });
      const [needsName, setNeedsName] = useState(false);
      const [isNameChange, setIsNameChange] = useState(false);
      const [oddsExpanded, setOddsExpanded] = useState(false);
      const [historyExpanded, setHistoryExpanded] = useState(false);
      const isMobile = useIsMobile();
      const userToggledHistory = useRef(false);

      // Real-time listener for shared boxes
      useEffect(() => {
        if (box.type === 'shared' && box.shareCode) {
          const unsubscribe = subscribeToSharedBox(box.shareCode, (updatedBox) => {
            if (updatedBox === null) {
              // Box was deleted by creator
              info('This box has been deleted by its creator');
              onBack();
              return;
            }
            setPullHistory(updatedBox.pullHistory || []);
          });
          return () => unsubscribe();
        }
      }, [box.shareCode, box.type]);

      // Reset state on unmount
      useEffect(() => {
        return () => {
          setOpeningPhase('idle');
          setShowResult(false);
          setCurrentPull(null);
        };
      }, []);

      const remainingPulls = box.maxPulls ? box.maxPulls - pullHistory.length : null;

      // Calculate per-user remaining pulls
      const currentUserName = userName || 'You';
      const currentDeviceId = getDeviceId();
      const userPullCount = pullHistory.filter(p =>
        p.deviceId === currentDeviceId ||
        (!p.deviceId && p.userName === currentUserName)
      ).length;
      const remainingUserPulls = box.maxPullsPerUser ? box.maxPullsPerUser - userPullCount : null;

      // Can pull only if ALL limits allow it
      const totalLimitOk = !box.maxPulls || pullHistory.length < box.maxPulls;
      const userLimitOk = !box.maxPullsPerUser || userPullCount < box.maxPullsPerUser;
      const isExpired = box.expiresAt ? Date.now() > box.expiresAt : false;
      const canPull = totalLimitOk && userLimitOk && !isExpired;

      // Calculate current odds with dynamic adjustment
      const currentOdds = calculateDynamicOdds(box.items, pullHistory);

      const handleBoxTap = () => {
        if (!canPull || openingPhase !== 'idle' || isExpired || currentOdds.length === 0) return;

        // Unlock audio on this user gesture (critical for iOS)
        _warmUpAudio();

        // Check if box is shared and needs user name
        if (box.type === 'shared' && (!userName || userName === 'Guest') && !needsName) {
          setNeedsName(true);
          return;
        }

        // Phase 1: Wiggle (0-400ms)
        setOpeningPhase('wiggle');

        setTimeout(() => {
          // Phase 2: Intense shake + glow (400-1600ms)
          setOpeningPhase('shaking');
          playBuildUpSound();

          // Do the actual pull calculation now (during shake animation)
          const totalPercentage = currentOdds.reduce((sum, item) => sum + item.adjustedPercentage, 0);
          let random = Math.random() * totalPercentage;
          let selectedItem = currentOdds[0];
          for (const item of currentOdds) {
            random -= item.adjustedPercentage;
            if (random <= 0) {
              selectedItem = item;
              break;
            }
          }

          const pull = {
            itemId: selectedItem.id,
            itemName: selectedItem.name,
            percentage: selectedItem.percentage,
            color: selectedItem.color,
            imageUrl: selectedItem.imageUrl || null,
            timestamp: Date.now(),
            userName: userName || 'You',
            deviceId: getDeviceId(),
          };

          setTimeout(() => {
            // Phase 3: Reveal (1600ms+)
            setOpeningPhase('reveal');
            setCurrentPull(pull);
            setShowResult(true);

            // Spawn particles
            if (particleContainerRef.current) {
              spawnParticles(particleContainerRef.current, selectedItem.color, 28);
            }

            // Play sound based on rarity
            if (selectedItem.percentage < 10) {
              playRareSound();
            } else {
              playRevealSound();
            }

            // Auto-expand history
            if (!historyExpanded && !userToggledHistory.current) {
              setHistoryExpanded(true);
            }

            // Save the pull
            if (box.type === 'shared') {
              addPullToSharedBox(box.shareCode, pull).catch(err => {
                console.error('Failed to save pull:', err);
                error('Failed to save open to shared box');
              });
            } else {
              const newHistory = [...pullHistory, pull];
              setPullHistory(newHistory);
              const updatedBox = { ...box, pullHistory: newHistory };
              saveBox(updatedBox);
              onBoxUpdate && onBoxUpdate(updatedBox);
            }

            // Phase 4: Done (after animations settle)
            setTimeout(() => {
              setOpeningPhase('done');
            }, 800);
          }, 1200);
        }, 400);
      };

      const handleNameSubmit = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (userName.trim()) {
          const trimmedName = userName.trim();
          // Save name for this specific box
          if (box.shareCode) {
            setBoxUserName(box.shareCode, trimmedName);
          }
          // Also save as last used name for pre-filling future boxes
          setLastUsedName(trimmedName);
          setNeedsName(false);
          if (isNameChange) {
            success('Name changed to ' + trimmedName);
            setIsNameChange(false);
          } else {
            handleBoxTap();
          }
        }
      };

      if (needsName) {
        return (
          <div style={{ maxWidth: '600px', margin: '0 auto' }}>
            <Card>
              <h2 style={{ fontSize: '1.5rem', fontWeight: 600, color: '#e2e8f0', marginBottom: '1rem' }}>
                Enter Your Name
              </h2>
              <p style={{ color: '#94a3b8', marginBottom: '1.5rem' }}>
                Enter your name for this box. Each box can have a different name.
              </p>
              <form onSubmit={handleNameSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                <Input
                  type="text"
                  placeholder="Your name"
                  value={userName}
                  onChange={(e) => setUserName(e.target.value)}
                  fullWidth
                  required
                />
                <div style={{ display: 'flex', gap: '1rem' }}>
                  <Button variant="ghost" onClick={onBack} fullWidth>Cancel</Button>
                  <Button type="submit" variant="primary" fullWidth>Continue</Button>
                </div>
              </form>
            </Card>
          </div>
        );
      }

      return (
        <div style={{ maxWidth: '1000px', margin: '0 auto' }}>
          {/* Header */}
          <div style={{ marginBottom: '1rem' }}>
            {/* Back button - left aligned, compact */}
            <Button variant="ghost" onClick={onBack} style={{ marginBottom: '0.5rem' }}>← Back</Button>

            {/* Box name - full width, centered */}
            <h2 style={{
              fontSize: '1.75rem',
              fontWeight: 700,
              color: '#e2e8f0',
              margin: '0 0 0.25rem 0',
              textAlign: 'center',
            }}>
              {box.name}
            </h2>

            {box.type === 'shared' && userName && (
              <div
                onClick={(e) => { e.stopPropagation(); setNeedsName(true); setIsNameChange(true); }}
                style={{
                  fontSize: '0.8rem',
                  color: '#94a3b8',
                  cursor: 'pointer',
                  textAlign: 'center',
                  marginBottom: '0.25rem',
                }}
              >
                Playing as <span style={{ color: '#60a5fa', fontWeight: 600 }}>{userName}</span> - tap to change
              </div>
            )}

            {/* Bottom row: Status badges */}
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.5rem', flexWrap: 'wrap' }}>
              {remainingPulls !== null && (
                <div style={{
                  padding: '0.5rem 1rem',
                  background: remainingPulls === 0 ? 'rgba(239, 68, 68, 0.2)' : 'rgba(59, 130, 246, 0.2)',
                  border: `1px solid ${remainingPulls === 0 ? '#ef4444' : '#3b82f6'}`,
                  borderRadius: '8px',
                  fontSize: '0.875rem',
                  fontWeight: 600,
                  color: remainingPulls === 0 ? '#fca5a5' : '#93c5fd',
                }}>
                  {remainingPulls}/{box.maxPulls} Opens Left
                </div>
              )}
              {remainingUserPulls !== null && (
                <div style={{
                  padding: '0.5rem 1rem',
                  background: remainingUserPulls === 0 ? 'rgba(239, 68, 68, 0.2)' : 'rgba(139, 92, 246, 0.2)',
                  border: `1px solid ${remainingUserPulls === 0 ? '#ef4444' : '#8b5cf6'}`,
                  borderRadius: '8px',
                  fontSize: '0.875rem',
                  fontWeight: 600,
                  color: remainingUserPulls === 0 ? '#fca5a5' : '#c4b5fd',
                }}>
                  You: {remainingUserPulls}/{box.maxPullsPerUser} Opens Left
                </div>
              )}
              {box.expiresAt && (
                <div style={{
                  padding: '0.5rem 1rem',
                  background: isExpired
                    ? 'rgba(239, 68, 68, 0.2)'
                    : isExpiringSoon(box.expiresAt)
                      ? 'rgba(245, 158, 11, 0.2)'
                      : 'rgba(16, 185, 129, 0.2)',
                  border: `1px solid ${
                    isExpired
                      ? '#ef4444'
                      : isExpiringSoon(box.expiresAt)
                        ? '#f59e0b'
                        : '#10b981'
                  }`,
                  borderRadius: '8px',
                  fontSize: '0.875rem',
                  fontWeight: 600,
                  color: isExpired
                    ? '#fca5a5'
                    : isExpiringSoon(box.expiresAt)
                      ? '#fcd34d'
                      : '#6ee7b7',
                }}>
                  {isExpired ? 'Expired' : formatExpirationCountdown(box.expiresAt) + ' left'}
                </div>
              )}

            </div>
          </div>

          {/* Main Opening Area */}
          <Card style={{
            marginBottom: '1.5rem',
            minHeight: '300px',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            position: 'relative',
            overflow: 'hidden',
          }}>

            {/* Glow ring - visible during shaking phase */}
            <div style={{
              position: 'absolute',
              width: '200px',
              height: '200px',
              borderRadius: '50%',
              opacity: 0,
              pointerEvents: 'none',
              animation: openingPhase === 'shaking' ? 'glowPulse 1.2s ease-in-out forwards' : 'none',
            }} />

            {/* Flash overlay - visible at reveal moment */}
            <div style={{
              position: 'absolute',
              inset: 0,
              background: 'radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%)',
              opacity: 0,
              zIndex: 5,
              pointerEvents: 'none',
              borderRadius: '16px',
              animation: openingPhase === 'reveal' ? 'flashBurst 0.6s ease-out forwards' : 'none',
            }} />

            {/* Particle container */}
            <div
              ref={particleContainerRef}
              style={{
                position: 'absolute',
                inset: 0,
                pointerEvents: 'none',
                zIndex: 4,
                overflow: 'hidden',
                borderRadius: '16px',
              }}
            />

            {/* Chest image - visible during idle, wiggle, shaking phases */}
            {(openingPhase === 'idle' || openingPhase === 'wiggle' || openingPhase === 'shaking') && (
              <div style={{ textAlign: 'center' }}>
                <div
                  onClick={openingPhase === 'idle' && canPull && !isExpired ? handleBoxTap : undefined}
                  style={{
                    width: '200px',
                    height: '200px',
                    margin: '0 auto 1.5rem',
                    cursor: openingPhase === 'idle' && canPull && !isExpired ? 'pointer' : 'default',
                    animation:
                      openingPhase === 'wiggle'
                        ? 'boxWiggle 0.4s ease'
                        : openingPhase === 'shaking'
                          ? 'intenseShake 1.2s ease-in-out'
                          : canPull && !isExpired
                            ? 'boxIdle 3s ease-in-out infinite'
                            : 'none',
                    transition: 'transform 0.2s ease',
                    filter: 'drop-shadow(0 0 25px rgba(59, 130, 246, 0.6))',
                    borderRadius: '16px',
                    zIndex: 2,
                    position: 'relative',
                  }}
                >
                  <img
                    src={getBoxImageUrl(box.boxImageId)}
                    alt={box.name}
                    style={{ width: '100%', height: '100%', objectFit: 'contain' }}
                    onError={(e) => { e.target.style.display = 'none'; e.target.nextSibling.style.display = 'block'; }}
                  />
                  <div style={{ fontSize: '6rem', display: 'none' }}>📦</div>
                </div>

                {openingPhase === 'idle' && canPull && !isExpired && (
                  <div style={{
                    fontSize: '1rem', color: '#94a3b8',
                    animation: 'tapHint 2s ease-in-out infinite',
                    marginTop: '-0.5rem', marginBottom: '0.5rem', fontWeight: 500,
                  }}>
                    {isMobile ? 'Tap to Open!' : 'Click to Open!'}
                  </div>
                )}

                {openingPhase === 'shaking' && (
                  <div style={{
                    fontSize: '1rem', color: '#f59e0b',
                    fontWeight: 600, marginTop: '-0.5rem',
                  }}>
                    Opening...
                  </div>
                )}

                {openingPhase === 'idle' && (isExpired || !canPull) && (
                  <>
                    <div style={{ fontSize: '1.25rem', color: '#fca5a5', marginBottom: '0.5rem' }}>
                      {isExpired ? 'This box has expired' : 'No opens remaining'}
                    </div>
                    <div style={{ fontSize: '0.875rem', color: '#64748b' }}>
                      {isExpired
                        ? 'You can still view the open history below'
                        : 'Check the open history to see what was opened'}
                    </div>
                  </>
                )}
              </div>
            )}

            {/* Result card - visible during reveal and done phases */}
            {(openingPhase === 'reveal' || openingPhase === 'done') && showResult && currentPull && (
              <div
                onClick={() => {
                  if (canPull && !isExpired) {
                    setOpeningPhase('idle');
                    setShowResult(false);
                    setCurrentPull(null);
                    if (particleContainerRef.current) particleContainerRef.current.innerHTML = '';
                  }
                }}
                style={{
                  textAlign: 'center',
                  padding: '3rem',
                  borderRadius: '16px',
                  background: isLightColor(currentPull.color)
                    ? `linear-gradient(135deg, ${currentPull.color}40 0%, ${currentPull.color}20 100%)`
                    : `linear-gradient(135deg, ${currentPull.color}40 0%, ${currentPull.color}20 100%)`,
                  border: isLightColor(currentPull.color)
                    ? '2px solid #94a3b8'
                    : `2px solid ${currentPull.color}`,
                  boxShadow: isLightColor(currentPull.color)
                    ? '0 0 40px rgba(100, 116, 139, 0.6)'
                    : `0 0 40px ${currentPull.color}60`,
                  width: '100%',
                  maxWidth: '500px',
                  cursor: canPull && !isExpired ? 'pointer' : 'default',
                  zIndex: 6,
                  position: 'relative',
                  opacity: 0,
                  transform: 'scale(0.3) translateY(20px)',
                  animation: 'resultReveal 0.7s cubic-bezier(0.34, 1.56, 0.64, 1) forwards',
                }}
              >
                {currentPull.imageUrl ? (
                  <img
                    src={currentPull.imageUrl}
                    alt={currentPull.itemName}
                    style={{
                      width: '80px', height: '80px',
                      objectFit: 'contain', borderRadius: '8px',
                      marginBottom: '1rem',
                      border: `2px solid ${currentPull.color}40`,
                    }}
                  />
                ) : null}
                <div style={{
                  fontSize: '2rem', fontWeight: 800, marginBottom: '0.5rem',
                  color: isLightColor(currentPull.color) ? '#1e293b' : currentPull.color,
                  animation: 'shimmerText 1.5s ease-in-out 0.5s',
                }}>
                  {currentPull.itemName}
                </div>
                <div style={{
                  fontSize: '1rem', fontWeight: 500,
                  color: isLightColor(currentPull.color) ? '#475569' : '#94a3b8',
                }}>
                  {currentPull.percentage}% chance
                </div>
                {canPull && !isExpired && (
                  <div style={{
                    fontSize: '0.875rem', color: '#64748b',
                    marginTop: '1rem',
                    animation: 'tapHint 2s ease-in-out infinite',
                  }}>
                    {isMobile ? 'Tap to open again!' : 'Click to open again!'}
                  </div>
                )}
              </div>
            )}

          </Card>

          <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : (box.hideOdds ? '1fr' : '1fr 1fr'), gap: isMobile ? '1rem' : '1.5rem' }}>
            {/* Current Odds - only show if not hidden */}
            {!box.hideOdds && (
              <Card>
                <div
                  onClick={() => setOddsExpanded(!oddsExpanded)}
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    cursor: 'pointer',
                    userSelect: 'none',
                    WebkitUserSelect: 'none',
                    minHeight: '44px',
                    padding: '0.25rem 0',
                  }}
                >
                  <h3 style={{
                    fontSize: '1.25rem',
                    fontWeight: 600,
                    color: '#e2e8f0',
                    margin: 0,
                  }}>
                    Current Odds
                  </h3>
                  <span style={{
                    fontSize: '1.25rem',
                    color: '#94a3b8',
                    transition: 'transform 0.25s ease',
                    transform: oddsExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                    display: 'inline-block',
                  }}>
                    ▼
                  </span>
                </div>

                {oddsExpanded && (
                  <div style={{ marginTop: '1rem' }}>
                    {currentOdds.length === 0 ? (
                      <div style={{ textAlign: 'center', padding: '2rem', color: '#64748b' }}>
                        All items claimed!
                      </div>
                    ) : (
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                        {currentOdds.map(item => (
                          <div
                            key={item.id}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '0.75rem',
                              padding: '0.75rem',
                              background: 'rgba(15, 22, 36, 0.6)',
                              border: `1px solid ${item.color}40`,
                              borderLeft: `3px solid ${item.color}`,
                              borderRadius: '8px',
                            }}
                          >
                            {item.imageUrl ? (
                              <img
                                src={item.imageUrl}
                                alt={item.name}
                                style={{
                                  width: '32px',
                                  height: '32px',
                                  objectFit: 'contain',
                                  borderRadius: '4px',
                                  border: `1px solid ${item.color}40`,
                                }}
                              />
                            ) : (
                              <span style={{
                                width: '10px',
                                height: '10px',
                                borderRadius: '50%',
                                background: item.color,
                                boxShadow: `0 0 8px ${item.color}80`,
                              }} />
                            )}
                            <span style={{ flex: 1, fontSize: '0.875rem', color: '#cbd5e1' }}>
                              {box.hideContents ? '???' : item.name}
                            </span>
                            <span style={{ fontSize: '1rem', fontWeight: 700, color: isLightColor(item.color) ? '#94a3b8' : item.color }}>
                              {item.adjustedPercentage.toFixed(1)}%
                            </span>
                            {item.remaining !== Infinity && (
                              <span style={{ fontSize: '0.75rem', color: '#64748b' }}>
                                ({item.remaining} left)
                              </span>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}
              </Card>
            )}

            {/* Pull History */}
            <Card>
              <div
                onClick={() => {
                  setHistoryExpanded(!historyExpanded);
                  userToggledHistory.current = true;
                }}
                style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  cursor: 'pointer',
                  userSelect: 'none',
                  WebkitUserSelect: 'none',
                  minHeight: '44px',
                  padding: '0.25rem 0',
                }}
              >
                <h3 style={{
                  fontSize: '1.25rem',
                  fontWeight: 600,
                  color: '#e2e8f0',
                  margin: 0,
                }}>
                  Open History ({pullHistory.length})
                </h3>
                <span style={{
                  fontSize: '1.25rem',
                  color: '#94a3b8',
                  transition: 'transform 0.25s ease',
                  transform: historyExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                  display: 'inline-block',
                }}>
                  ▼
                </span>
              </div>

              {historyExpanded && (
                <div style={{ marginTop: '1rem' }}>
                  {pullHistory.length === 0 ? (
                    <div style={{ textAlign: 'center', padding: '2rem', color: '#64748b' }}>
                      No opens yet
                    </div>
                  ) : (
                    <div style={{
                      display: 'flex',
                      flexDirection: 'column',
                      gap: '0.5rem',
                      maxHeight: '400px',
                      overflowY: 'auto',
                    }}>
                      {pullHistory.slice().reverse().map((pull, idx) => {
                        // Current user can see their own pulls, but hideContents hides items pulled by others
                        const isCurrentUserPull = pull.userName === (userName || 'You');
                        const shouldHideItemName = box.hideContents && !isCurrentUserPull;

                        return (
                          <div
                            key={idx}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '0.5rem',
                              padding: '0.5rem',
                              background: 'rgba(15, 22, 36, 0.4)',
                              borderRadius: '6px',
                              fontSize: '0.875rem',
                            }}
                          >
                            {pull.imageUrl && !shouldHideItemName ? (
                              <img
                                src={pull.imageUrl}
                                alt={pull.itemName}
                                style={{
                                  width: '24px',
                                  height: '24px',
                                  objectFit: 'contain',
                                  borderRadius: '3px',
                                  border: `1px solid ${pull.color}40`,
                                }}
                              />
                            ) : (
                              <span style={{
                                width: '8px',
                                height: '8px',
                                borderRadius: '50%',
                                background: pull.color,
                              }} />
                            )}
                            <span style={{ color: '#cbd5e1' }}>
                              {shouldHideItemName ? 'Mystery Item' : pull.itemName}
                            </span>
                            <span style={{ marginLeft: 'auto', color: '#64748b', fontSize: '0.75rem' }}>
                              {pull.userName}
                            </span>
                            <span style={{ color: '#475569', fontSize: '0.75rem' }}>
                              {new Date(pull.timestamp).toLocaleTimeString()}
                            </span>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              )}
            </Card>
          </div>
        </div>
      );
    };

    // ========== MAIN APP ==========
    
    const App = () => {
      const isMobile = useIsMobile();
      const [mode, setMode] = useState('home'); // home, create, edit, open
      const [activeFilter, setActiveFilter] = useState('All');
      const [favorites, setFavorites] = useState(getFavorites());
      const [boxes, setBoxes] = useState([]);
      const [userSettings, setUserSettings] = useState(null);
      const [editingBox, setEditingBox] = useState(null);
      const [openingBox, setOpeningBox] = useState(null);
      const [pendingTemplate, setPendingTemplate] = useState(null);
      const [showSettings, setShowSettings] = useState(false);
      const [drawerOpen, setDrawerOpen] = useState(false);
      const [showAboutModal, setShowAboutModal] = useState(false);
      const { showToast, toastElement, success, error, info } = useToast();

      // Tick to keep expiration badges fresh (1s when under 1min, else 30s)
      const [, setTick] = useState(0);
      const boxesRef = useRef(boxes);
      useEffect(() => { boxesRef.current = boxes; }, [boxes]);

      useEffect(() => {
        const getInterval = () => {
          const hasExpiringSoon = boxesRef.current.some(b =>
            b.expiresAt && b.expiresAt - Date.now() > 0 && b.expiresAt - Date.now() < 60000
          );
          return hasExpiringSoon ? 1000 : 30000;
        };

        let timer = setInterval(() => setTick(t => t + 1), getInterval());

        // Re-check interval every 30s to switch between fast/slow
        const checker = setInterval(() => {
          clearInterval(timer);
          timer = setInterval(() => setTick(t => t + 1), getInterval());
        }, 30000);

        return () => {
          clearInterval(timer);
          clearInterval(checker);
        };
      }, []);

      const loadTemplate = async (shareCode) => {
        const templateData = await fetchBoxTemplate(shareCode);
        if (templateData) {
          setPendingTemplate(templateData);
        } else {
          error('Template not found or link expired');
        }
        window.location.hash = '';
      };

      const handleConfirmImport = () => {
        if (!pendingTemplate) return;

        if (!canCreateLocalBox()) {
          error("You've reached the free tier limit of 5 local boxes. Delete a box or upgrade to Premium to import this template.");
          setPendingTemplate(null);
          return;
        }

        importBoxFromTemplate(pendingTemplate);
        setPendingTemplate(null);
        loadData();
        success('Box imported successfully!');
      };

      const handleSaveSettings = (updatedSettings) => {
        saveUserSettings(updatedSettings);
        setUserSettings(updatedSettings);
      };

      const handleCancelImport = () => {
        setPendingTemplate(null);
      };

      useEffect(() => {
        migrateOldName();
        loadData();

        // Check for shared box URL
        const hash = window.location.hash;
        const match = hash.match(/^#\/box\/([A-Z0-9]{6})$/);
        if (match) {
          const shareCode = match[1];
          loadSharedBox(shareCode);
        }

        // Check for template URL
        const templateMatch = hash.match(/^#\/template\/([A-Z0-9]{6})$/);
        if (templateMatch) {
          loadTemplate(templateMatch[1]);
        }

        // Listen for hash changes
        const handleHashChange = () => {
          const hash = window.location.hash;
          const match = hash.match(/^#\/box\/([A-Z0-9]{6})$/);
          if (match) {
            loadSharedBox(match[1]);
          }
          const templateMatch = hash.match(/^#\/template\/([A-Z0-9]{6})$/);
          if (templateMatch) {
            loadTemplate(templateMatch[1]);
          }
        };
        window.addEventListener('hashchange', handleHashChange);
        return () => window.removeEventListener('hashchange', handleHashChange);
      }, []);

      useEffect(() => {
        // Subscribe to real-time updates for all shared boxes
        const unsubscribers = [];

        boxes.forEach((box) => {
          if (box.type === 'shared' && box.shareCode) {
            const unsub = subscribeToSharedBox(box.shareCode, (updatedBox) => {
              if (updatedBox) {
                setBoxes(prev => prev.map(b => {
                  if (b.shareCode === box.shareCode) {
                    const updated = {
                      ...b,
                      ...updatedBox,
                      id: b.id,
                      isSharedRef: b.isSharedRef,
                      isVisitor: b.isVisitor,
                    };
                    // Also persist to localStorage
                    saveBox(updated);
                    return updated;
                  }
                  return b;
                }));
              }
            });
            unsubscribers.push(unsub);
          }
        });

        return () => {
          unsubscribers.forEach(unsub => unsub());
        };
      }, [boxes.filter(b => b.type === 'shared').map(b => b.shareCode).join(',')]);

      const loadData = async () => {
        const loadedBoxes = getAllBoxes();
        const settings = getUserSettings();

        // Fetch fresh pull counts for shared boxes from Firestore
        const updatedBoxes = await Promise.all(
          loadedBoxes.map(async (box) => {
            if (box.type === 'shared' && box.shareCode) {
              try {
                const freshBox = await fetchSharedBox(box.shareCode);
                if (freshBox) {
                  return {
                    ...box,
                    ...freshBox,
                    id: box.id,
                    isSharedRef: box.isSharedRef,
                    isVisitor: box.isVisitor,
                  };
                }
              } catch (err) {
                console.error('Error fetching shared box:', err);
              }
            }
            return box;
          })
        );

        // Persist updated shared box data back to localStorage
        updatedBoxes.forEach((box) => {
          if (box.type === 'shared' && box.shareCode) {
            saveBox(box);
          }
        });

        setBoxes(updatedBoxes);
        setUserSettings(settings);
      };

      const loadSharedBox = async (shareCode) => {
        const box = await fetchSharedBox(shareCode);
        if (box) {
          // Save a read-only reference so visitor sees it in their feed
          const existingBoxes = getAllBoxes();
          const alreadySaved = existingBoxes.some(
            b => b.shareCode === shareCode
          );

          if (!alreadySaved) {
            const visitorRef = {
              id: box.id,
              name: box.name,
              type: 'shared',
              shareCode: box.shareCode,
              isSharedRef: true,
              isVisitor: true,  // THIS IS THE KEY FLAG
              items: box.items,
              maxPulls: box.maxPulls,
              maxPullsPerUser: box.maxPullsPerUser || null,
              pullHistory: [],  // will be fetched from Firestore
              createdAt: box.createdAt,
              boxImageId: box.boxImageId,
              hideContents: box.hideContents,
              hideOdds: box.hideOdds,
              expiresAt: box.expiresAt || null,
              allowParticipantSharing: box.allowParticipantSharing || false,
            };
            saveBox(visitorRef);
            loadData();  // refresh the box list
          }

          setOpeningBox(box);
          setMode('open');
        } else {
          error('This box no longer exists or the link is invalid');
        }
      };

      const handleCreateBox = () => {
        setEditingBox(null);
        setMode('create');
      };

      const handleEditBox = (box) => {
        if (box.isVisitor) {
          info('You can only view shared boxes you joined');
          return;
        }
        setEditingBox(box);
        setMode('edit');
      };

      const handleDeleteBox = async (boxId) => {
        const box = boxes.find(b => b.id === boxId);

        // If shared box AND creator (not visitor), delete from Firestore
        if (box && box.type === 'shared' && box.shareCode && !box.isVisitor) {
          const deleted = await deleteSharedBox(box.shareCode);
          if (!deleted) {
            error('Failed to delete shared box from server');
            return;
          }
        }

        // Delete local reference (works for both creator and visitor)
        deleteBox(boxId);

        if (openingBox && openingBox.id === boxId) {
          setOpeningBox(null);
          setMode('home');
        }

        loadData();
        success(box?.isVisitor ? 'Removed from your feed' : 'Box deleted successfully');
      };

      // Lock body scroll when drawer is open
      useEffect(() => {
        document.body.style.overflow = drawerOpen ? 'hidden' : '';
        return () => { document.body.style.overflow = ''; };
      }, [drawerOpen]);

      const handleDrawerNavigate = (key) => {
        if (key === 'toggleTier') {
          const settings = getUserSettings();
          const newTier = settings.tier === 'paid' ? 'free' : 'paid';
          saveUserSettings({ ...settings, tier: newTier });
          setUserSettings({ ...settings, tier: newTier });
          loadData();
          info(`Switched to ${newTier === 'paid' ? 'Premium' : 'Free'} tier`);
          return;
        }
        setDrawerOpen(false);
        switch (key) {
          case 'myBoxes': setMode('home'); break;
          case 'marketplace': info('Marketplace coming soon!'); break;
          case 'templates': info('Browse templates when creating a box'); break;
          case 'stats': info('Stats coming soon!'); break;
          case 'account': info('Account system coming soon!'); break;
          case 'settings': setTimeout(() => setShowSettings(true), 100); break;
          case 'shareApp': {
            const appUrl = `${window.location.origin}${window.location.pathname}`;
            if (navigator.share) {
              navigator.share({ title: 'Loot Box Creator', text: 'Create, customize, and share loot boxes with friends!', url: appUrl }).catch(() => {});
            } else {
              navigator.clipboard.writeText(appUrl).then(() => success('Link copied!')).catch(() => {});
            }
            break;
          }
          case 'about': setTimeout(() => setShowAboutModal(true), 100); break;
        }
      };

      const handleToggleFavorite = (boxId) => {
        const newFavs = toggleFavorite(boxId);
        setFavorites([...newFavs]);
      };

      const handleBoxSaved = (box) => {
        loadData();
        setMode('home');
        setEditingBox(null);
        success(editingBox ? 'Box updated successfully!' : `${box.name} created successfully!`);
      };

      const handleCancel = () => {
        setMode('home');
        setEditingBox(null);
      };

      const handleOpenBox = async (box) => {
        markBoxAsSeen(box.id);
        if (box.type === 'shared' && box.shareCode) {
          const freshBox = await fetchSharedBox(box.shareCode);
          if (freshBox) {
            setOpeningBox(freshBox);
            setMode('open');
          } else {
            // Box was deleted - clean up local reference
            deleteBox(box.id);
            loadData();
            error('This box no longer exists. It has been removed from your list.');
            return;
          }
        } else {
          setOpeningBox(box);
          setMode('open');
        }
      };

      const handleBoxUpdate = (updatedBox) => {
        loadData();
        setOpeningBox(updatedBox);
      };

      const handleCloseOpener = () => {
        setMode('home');
        setOpeningBox(null);
        loadData(); // Reload to show updated pull counts
      };

      let filteredBoxes = boxes.filter(box => {
        if (activeFilter === 'Local') return box.type === 'local';
        if (activeFilter === 'Shared') return box.type === 'shared';
        if (activeFilter === 'New') {
          // Show boxes that haven't been opened yet
          return !box.pullHistory || box.pullHistory.length === 0;
        }
        if (activeFilter === 'Faves') {
          const favId = box.shareCode || box.id;
          return favorites.includes(favId);
        }
        if (activeFilter === 'All') return true;
        return true;
      });

      // Sort "All" filter by newest first, then by most recently used
      if (activeFilter === 'All') {
        filteredBoxes = filteredBoxes.sort((a, b) => {
          const getLastActivity = (box) => {
            const lastPull = (box.pullHistory && box.pullHistory.length > 0)
              ? Math.max(...box.pullHistory.map(p => p.timestamp || 0))
              : 0;
            return Math.max(lastPull, box.createdAt || 0);
          };
          return getLastActivity(b) - getLastActivity(a);
        });
      }

      if (!userSettings) return <div>Loading...</div>;

      return (
        <div style={{ maxWidth: '1200px', margin: '0 auto', padding: isMobile ? '1rem' : '2rem', minHeight: '100vh' }}>
          <Header
            onMenuClick={() => setDrawerOpen(true)}
          />

          {mode === 'home' && (
            <>
              <FilterTabs activeFilter={activeFilter} onFilterChange={setActiveFilter} filters={['All', 'Shared', 'New', 'Faves', 'Local']} />

              <button
                onClick={handleCreateBox}
                style={{
                  width: '100%',
                  padding: isMobile ? '1rem 1.5rem' : '0.75rem 1.5rem',
                  fontSize: isMobile ? '1.1rem' : '1rem',
                  fontWeight: 700,
                  fontFamily: 'inherit',
                  color: '#ffffff',
                  background: 'linear-gradient(135deg, #f59e0b 0%, #ef4444 50%, #ec4899 100%)',
                  border: 'none',
                  borderRadius: '14px',
                  cursor: 'pointer',
                  marginBottom: '1.5rem',
                  boxShadow: '0 4px 20px rgba(245, 158, 11, 0.4), 0 0 40px rgba(245, 158, 11, 0.1)',
                  letterSpacing: '0.02em',
                  transition: 'all 0.25s ease',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  minHeight: isMobile ? '56px' : '48px',
                }}
              >
                + Create New Loot Box
              </button>

              {filteredBoxes.length === 0 ? (
                <div style={{ textAlign: 'center', padding: '4rem 2rem', color: '#64748b' }}>
                  {activeFilter === 'Faves' ? (
                    <>
                      <div style={{ marginBottom: '1rem', opacity: 0.5 }}>
                        <svg width="40" height="40" viewBox="0 0 24 24" style={{ fill: 'none', stroke: '#64748b', strokeWidth: 1.5 }}>
                          <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
                        </svg>
                      </div>
                      <div style={{ fontSize: '1.125rem', marginBottom: '0.5rem' }}>No favorites yet</div>
                      <div style={{ fontSize: '0.875rem', color: '#475569' }}>Tap the star on any box to add it here</div>
                    </>
                  ) : (
                    <>
                      <div style={{ fontSize: '4rem', marginBottom: '1rem', opacity: 0.5 }}>📦</div>
                      <div style={{ fontSize: '1.125rem', marginBottom: '0.5rem' }}>
                        {activeFilter === 'Local' && 'No local boxes yet'}
                        {activeFilter === 'Shared' && 'No shared boxes yet'}
                        {activeFilter === 'New' && 'No unopened boxes'}
                        {activeFilter === 'All' && 'No boxes yet'}
                      </div>
                      <div style={{ fontSize: '0.875rem', color: '#475569' }}>
                        {activeFilter === 'New' ? 'All your boxes have been opened!' : 'Create your first loot box to get started!'}
                      </div>
                    </>
                  )}
                </div>
              ) : (
                <div style={{
                  display: 'grid',
                  gridTemplateColumns: isMobile ? '1fr' : 'repeat(auto-fill, minmax(300px, 1fr))',
                  gap: isMobile ? '1rem' : '1.5rem',
                  marginTop: isMobile ? '1rem' : '2rem',
                }}>
                  {filteredBoxes.map(box => (
                    <BoxCard
                      key={box.id}
                      box={box}
                      onClick={() => handleOpenBox(box)}
                      onEdit={handleEditBox}
                      onDelete={handleDeleteBox}
                      success={success}
                      isNew={!getSeenBoxes().includes(box.id)}
                      isFav={favorites.includes(box.shareCode || box.id)}
                      onToggleFavorite={handleToggleFavorite}
                    />
                  ))}
                </div>
              )}
            </>
          )}

          {(mode === 'create' || mode === 'edit') && (
            <BoxCreator
              onComplete={handleBoxSaved}
              onCancel={handleCancel}
              editingBox={editingBox}
              success={success}
              error={error}
              info={info}
            />
          )}

          {mode === 'open' && openingBox && (
            <BoxOpener
              box={openingBox}
              onBack={handleCloseOpener}
              onBoxUpdate={handleBoxUpdate}
              success={success}
              error={error}
              info={info}
            />
          )}

          {/* Template Import Confirmation Dialog */}
          {pendingTemplate && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.7)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '1rem',
            }}>
              <Card style={{ maxWidth: '450px', width: '100%' }}>
                <h3 style={{ fontSize: '1.25rem', fontWeight: 700, color: '#e2e8f0', marginBottom: '0.5rem' }}>
                  Import Box Template?
                </h3>
                <p style={{ color: '#94a3b8', fontSize: '0.875rem', marginBottom: '1rem' }}>
                  Import "{pendingTemplate.name}" by {pendingTemplate.createdBy}? This will create a new local box with the same items and settings.
                </p>

                <div style={{ marginBottom: '1rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.875rem', color: '#94a3b8', marginBottom: '0.5rem' }}>
                    <span>Items:</span>
                    <span style={{ fontWeight: 600, color: '#cbd5e1' }}>{(pendingTemplate.items || []).length}</span>
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.875rem', color: '#94a3b8', marginBottom: '0.75rem' }}>
                    <span>Created by:</span>
                    <span style={{ fontWeight: 600, color: '#cbd5e1' }}>{pendingTemplate.createdBy}</span>
                  </div>

                  <div style={{
                    maxHeight: '200px',
                    overflowY: 'auto',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '0.25rem',
                  }}>
                    {(pendingTemplate.items || []).map((item, idx) => (
                      <div key={idx} style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '0.5rem',
                        padding: '0.35rem 0.5rem',
                        background: 'rgba(15, 22, 36, 0.4)',
                        borderRadius: '6px',
                        fontSize: '0.8rem',
                      }}>
                        <span style={{
                          width: '8px',
                          height: '8px',
                          borderRadius: '50%',
                          background: item.color || '#3b82f6',
                          flexShrink: 0,
                        }} />
                        <span style={{ color: '#cbd5e1', flex: 1 }}>{item.name}</span>
                        <span style={{ color: '#64748b' }}>{item.percentage}%</span>
                      </div>
                    ))}
                  </div>
                </div>

                <div style={{ display: 'flex', gap: '1rem' }}>
                  <Button variant="ghost" onClick={handleCancelImport} fullWidth>Cancel</Button>
                  <Button variant="primary" onClick={handleConfirmImport} fullWidth>Import</Button>
                </div>
              </Card>
            </div>
          )}

          <SettingsModal
            show={showSettings}
            onClose={() => setShowSettings(false)}
            userSettings={userSettings}
            onSave={handleSaveSettings}
          />

          <SideDrawer
            isOpen={drawerOpen}
            onClose={() => setDrawerOpen(false)}
            userSettings={userSettings}
            onNavigate={handleDrawerNavigate}
          />

          <AboutModal
            show={showAboutModal}
            onClose={() => setShowAboutModal(false)}
          />

          {toastElement}
        </div>
      );
    };

    // Render
    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
