================================================================================
FIX: Color picker dropdown blocked by ItemList empty state (v3 - fixed position)
================================================================================

PROBLEM:
The color picker dropdown renders inside the ItemCreator Card, but
backdrop-filter on the Card creates a new stacking context that cannot be
escaped with z-index alone. The ItemList empty state below always renders
on top of the dropdown.

FIX:
Use position: fixed for the dropdown and calculate its position from the
trigger button's bounding rect. This renders the dropdown at the viewport
level, completely independent of any parent overflow or stacking context.

Also revert the previous z-index/overflow changes since they're not needed.

================================================================================
CHANGES REQUIRED IN: index.html (ItemCreator component)
================================================================================

CHANGE 1: Revert the Card overflow change (if applied)
---------------------------------------------------------------------------
If the Card was changed to:

        <Card style={{ marginBottom: '2rem', overflow: 'visible' }}>

Revert it back to:

        <Card style={{ marginBottom: '2rem' }}>


CHANGE 2: Revert the wrapper z-index (if applied)
---------------------------------------------------------------------------
If the wrapper div was changed to:

            <div ref={colorPickerRef} style={{ position: 'relative', zIndex: 100 }}>

Revert it back to:

            <div ref={colorPickerRef} style={{ position: 'relative' }}>


CHANGE 3: Add a ref to the trigger button
---------------------------------------------------------------------------
Near the other refs/state in ItemCreator (where colorPickerRef is), add:

    const colorButtonRef = useRef(null);


CHANGE 4: Add ref attribute to the trigger button
---------------------------------------------------------------------------
Find the color picker trigger button:

              <button
                type="button"
                onClick={() => setColorPickerOpen(!colorPickerOpen)}

Add the ref right after type="button":

              <button
                type="button"
                ref={colorButtonRef}
                onClick={() => setColorPickerOpen(!colorPickerOpen)}


CHANGE 5: Replace the dropdown with a fixed-position overlay
---------------------------------------------------------------------------
Find the entire dropdown block that renders when colorPickerOpen is true.
It currently looks like this:

              {colorPickerOpen && (
                <div style={{
                  position: 'absolute',
                  top: '100%',
                  left: 0,
                  right: 0,
                  marginTop: '0.5rem',
                  padding: '0.75rem',
                  background: 'rgba(15, 22, 36, 0.95)',
                  border: '2px solid rgba(59, 130, 246, 0.3)',
                  borderRadius: '12px',
                  backdropFilter: 'blur(12px)',
                  boxShadow: '0 8px 32px rgba(0, 0, 0, 0.5)',
                  zIndex: 50,
                  animation: 'fadeIn 0.15s ease',
                }}>
                  <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(5, 1fr)',
                    gap: '0.4rem',
                  }}>
                    {predefinedColors.map(color => (
                      <button
                        key={color}
                        type="button"
                        style={{
                          width: '100%',
                          aspectRatio: '1',
                          background: color,
                          borderRadius: '6px',
                          border: itemForm.color === color
                            ? '2px solid #ffffff'
                            : color === '#ffffff'
                              ? '2px solid rgba(148, 163, 184, 0.5)'
                              : '2px solid rgba(59, 130, 246, 0.15)',
                          cursor: 'pointer',
                          transform: itemForm.color === color ? 'scale(1.1)' : 'scale(1)',
                          boxShadow: itemForm.color === color ? `0 0 12px ${color}80` : 'none',
                          transition: 'all 0.15s ease',
                        }}
                        onClick={() => {
                          setItemForm({ ...itemForm, color });
                          setColorPickerOpen(false);
                        }}
                      />
                    ))}
                  </div>
                </div>
              )}

REPLACE THAT ENTIRE BLOCK WITH:

              {colorPickerOpen && (() => {
                const rect = colorButtonRef.current?.getBoundingClientRect();
                if (!rect) return null;
                return ReactDOM.createPortal(
                  <>
                    {/* Invisible backdrop to catch outside clicks */}
                    <div
                      onClick={() => setColorPickerOpen(false)}
                      style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        zIndex: 9998,
                      }}
                    />
                    {/* The actual color grid */}
                    <div style={{
                      position: 'fixed',
                      top: rect.bottom + 8,
                      left: rect.left,
                      width: rect.width,
                      padding: '0.75rem',
                      background: 'rgba(15, 22, 36, 0.98)',
                      border: '2px solid rgba(59, 130, 246, 0.3)',
                      borderRadius: '12px',
                      boxShadow: '0 8px 32px rgba(0, 0, 0, 0.6)',
                      zIndex: 9999,
                      animation: 'fadeIn 0.15s ease',
                    }}>
                      <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(5, 1fr)',
                        gap: '0.4rem',
                      }}>
                        {predefinedColors.map(color => (
                          <button
                            key={color}
                            type="button"
                            style={{
                              width: '100%',
                              aspectRatio: '1',
                              background: color,
                              borderRadius: '6px',
                              border: itemForm.color === color
                                ? '2px solid #ffffff'
                                : color === '#ffffff'
                                  ? '2px solid rgba(148, 163, 184, 0.5)'
                                  : '2px solid rgba(59, 130, 246, 0.15)',
                              cursor: 'pointer',
                              transform: itemForm.color === color ? 'scale(1.1)' : 'scale(1)',
                              boxShadow: itemForm.color === color ? `0 0 12px ${color}80` : 'none',
                              transition: 'all 0.15s ease',
                            }}
                            onClick={() => {
                              setItemForm({ ...itemForm, color });
                              setColorPickerOpen(false);
                            }}
                          />
                        ))}
                      </div>
                    </div>
                  </>,
                  document.body
                );
              })()}


CHANGE 6: Simplify the click-outside handler
---------------------------------------------------------------------------
Since we now use a portal with an invisible backdrop for outside clicks,
the mousedown/touchstart useEffect is no longer needed. Find and REMOVE
this entire useEffect:

    useEffect(() => {
      const handleClickOutside = (e) => {
        if (colorPickerRef.current && !colorPickerRef.current.contains(e.target)) {
          setColorPickerOpen(false);
        }
      };
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('touchstart', handleClickOutside);
      return () => {
        document.removeEventListener('mousedown', handleClickOutside);
        document.removeEventListener('touchstart', handleClickOutside);
      };
    }, []);

The invisible backdrop div in the portal now handles this instead.

You can also remove the colorPickerRef since it's no longer used for
click-outside detection. Remove:

    const colorPickerRef = useRef(null);

And change the wrapper div from:

            <div ref={colorPickerRef} style={{ position: 'relative' }}>

To just:

            <div style={{ position: 'relative' }}>


================================================================================
HOW IT WORKS
================================================================================

ReactDOM.createPortal renders the dropdown directly into document.body,
completely outside the React component tree's DOM hierarchy. This means:

- No parent overflow, backdrop-filter, or stacking context can clip it
- z-index: 9999 puts it above everything
- The invisible backdrop (z-index: 9998) catches taps outside to close
- Position is calculated from the trigger button's getBoundingClientRect()
- The grid renders at the correct viewport position below the button

================================================================================
TESTING
================================================================================
1. Create Box with no items -- click color picker
2. ALL 5 rows of colors should be fully visible, nothing overlapping
3. The "No items added yet" message should be completely hidden behind grid
4. Tap a color in any row -- dropdown closes, color updates on button
5. Tap outside the grid -- dropdown closes
6. Scroll the page, open the picker -- it should still align to the button
7. Test on mobile -- touch works, no bleed-through
8. Edit an existing item -- color picker still works correctly
